<html lang="en">
<head>
<title>The Subversion Handbook</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="The Subversion Handbook">
<meta name=generator content="makeinfo 4.1">
<link href="http://texinfo.org/" rel=generator-home>
</head>
<body>
<h1>The Subversion Handbook</h1>
<body bgcolor="#FFFFFF" fgcolor="#000000">


<h2>Short Contents</h2>
<ul>
<li><a href="#toc_Top"></a>
<li><a href="#toc_Getting%20Started">Getting Started</a>
<li><a href="#toc_Client%20Cookbook">Client Cookbook</a>
<li><a href="#toc_Repository%20Administration">Repository Administration</a>
<li><a href="#toc_Appendices">Appendices</a>
</ul>


<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top"></a>
    <a href="#Top"></a>
<li><a name="toc_Getting%20Started"></a>
    <a href="#Getting%20Started">Getting Started</a>
<ul>
<li><a href="#Introduction">Introduction</a>
<ul>
<li><a href="#Introduction">A Revision Control System</a>
<li><a href="#Introduction">History</a>
<li><a href="#Introduction">Audience</a>
<li><a href="#Introduction">Features</a>
</ul>
<li><a href="#Design">Design</a>
<ul>
<li><a href="#Design">Filesystem</a>
<li><a href="#Design">Network Layer</a>
<li><a href="#Design">Client Libraries</a>
</ul>
<li><a href="#Installation">Installation</a>
<li><a href="#Basics">Basics</a>
<ul>
<li><a href="#The%20Subversion%20Development%20Model">The Subversion Development Model</a>
<ul>
<li><a href="#Working%20Directories%20and%20Repositories">Working Directories and Repositories</a>
<li><a href="#Transactions%20and%20Revision%20Numbers">Transactions and Revision Numbers</a>
<li><a href="#How%20Working%20Directories%20Track%20the%20Repository">How Working Directories Track the Repository</a>
<li><a href="#Subversion%20Does%20Not%20Lock%20Files">Subversion Does Not Lock Files</a>
</ul>
<li><a href="#Quick%20Walkthrough">Quick Walkthrough</a>
<ul>
<li><a href="#Make%20a%20repository">Make a repository</a>
<li><a href="#Make%20some%20working%20copies">Make some working copies</a>
</ul>
</ul>
</ul>
<li><a name="toc_Client%20Cookbook"></a>
    <a href="#Client%20Cookbook">Client Cookbook</a>
<ul>
<li><a href="#Checkout">Checkout</a>
<li><a href="#Basic%20Work%20Cycle">Basic Work Cycle</a>
<ul>
<li><a href="#Basic%20Work%20Cycle">Update your working copy (<code>svn up</code>)</a>
<li><a href="#Basic%20Work%20Cycle">Make changes  (<code>svn add</code>, <code>svn rm</code>, <code>svn cp</code>, <code>mv</code>)</a>
<li><a href="#Basic%20Work%20Cycle">Examine your changes  (<code>svn status</code>, <code>svn diff</code>, <code>svn revert</code>)</a>
<li><a href="#Basic%20Work%20Cycle">Merge others' changes  (conflict resolution)</a>
<li><a href="#Basic%20Work%20Cycle">Commit your changes</a>
</ul>
<li><a href="#History">History</a>
<ul>
<li><a href="#History"><code>svn log</code></a>
<li><a href="#History"><code>svn diff</code></a>
<ul>
<li><a href="#History">Examining local changes</a>
<li><a href="#History">Comparing working copy to repository</a>
<li><a href="#History">Comparing repository to repository</a>
</ul>
</ul>
<li><a href="#Branches%20and%20Tags">Branches and Tags</a>
<ul>
<li><a href="#Branches%20and%20Tags">Branching with <code>svn cp</code></a>
<li><a href="#Branches%20and%20Tags">Switching to a branch with <code>svn switch</code></a>
<li><a href="#Branches%20and%20Tags">Moving changes with <code>svn merge</code></a>
<li><a href="#Branches%20and%20Tags">Rolling back a change with <code>svn merge</code></a>
<li><a href="#Branches%20and%20Tags">Vendor branches</a>
<li><a href="#Branches%20and%20Tags">Removing a branch or tag with <code>svn rm</code></a>
</ul>
<li><a href="#Properties">Properties</a>
<ul>
<li><a href="#Properties">Special properties</a>
<ul>
<li><a href="#Properties"><code>svn:executable</code></a>
<li><a href="#Properties"><code>svn:mime-type</code></a>
<li><a href="#Properties"><code>svn:ignore</code></a>
<li><a href="#Properties"><code>svn:keywords</code></a>
<li><a href="#Properties"><code>svn:eol-style</code></a>
<li><a href="#Properties"><code>svn:externals</code></a>
</ul>
</ul>
<li><a href="#Modules">Modules</a>
<li><a href="#Revisions">Revisions</a>
<li><a href="#Other%20Commands">Other Commands</a>
<li><a href="#Run-time%20Configuration">Run-time Configuration</a>
<ul>
<li><a href="#Run-time%20Configuration">Proxies</a>
<li><a href="#Run-time%20Configuration">Config</a>
<li><a href="#Run-time%20Configuration">Multiple config areas</a>
</ul>
</ul>
<li><a name="toc_Repository%20Administration"></a>
    <a href="#Repository%20Administration">Repository Administration</a>
<ul>
<li><a href="#Creating%20a%20repository">Creating a repository</a>
<li><a href="#Examining%20a%20repository">Examining a repository</a>
<ul>
<li><a href="#Examining%20a%20repository">Transactions and Revisions</a>
<li><a href="#Examining%20a%20repository"><code>svnlook</code></a>
<li><a href="#Examining%20a%20repository">the shell</a>
</ul>
<li><a href="#Repository%20hooks">Repository hooks</a>
<li><a href="#Repository%20maintenance">Repository maintenance</a>
<ul>
<li><a href="#Repository%20maintenance">Berkeley DB management</a>
<li><a href="#Repository%20maintenance">Tweaking with svnadmin</a>
</ul>
<li><a href="#Networking%20a%20repository">Networking a repository</a>
<li><a href="#Migrating%20a%20repository">Migrating a repository</a>
<ul>
<li><a href="#Migrating%20a%20repository">Stupid dump/load tricks</a>
</ul>
<li><a href="#WebDAV">WebDAV</a>
</ul>
<li><a name="toc_Appendices"></a>
    <a href="#Appendices">Appendices</a>
<ul>
<li><a href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<ul>
<li><a href="#Revision%20numbers%20are%20different%20now">Revision numbers are different now</a>
<li><a href="#More%20disconnected%20operations">More disconnected operations</a>
<li><a href="#Distinction%20between%20status%20and%20update">Distinction between status and update</a>
<li><a href="#Meta-data%20properties">Meta-data properties</a>
<li><a href="#Directory%20versions">Directory versions</a>
<li><a href="#Conflicts">Conflicts</a>
<li><a href="#Binary%20files">Binary files</a>
<li><a href="#Authorization">Authorization</a>
<li><a href="#Versioned%20Modules">Versioned Modules</a>
<li><a href="#Branches%20and%20tags">Branches and tags</a>
</ul>
<li><a href="#Directory%20versioning">Directory versioning</a>
<ul>
<li><a href="#Directory%20versioning">Directory Revisions</a>
<li><a href="#Directory%20versioning">The Lagging Directory</a>
<ul>
<li><a href="#Directory%20versioning">Problem</a>
<li><a href="#Directory%20versioning">Solution</a>
</ul>
<li><a href="#Directory%20versioning">The Overeager Directory</a>
<ul>
<li><a href="#Directory%20versioning">Problem</a>
<li><a href="#Directory%20versioning">Solution</a>
</ul>
<li><a href="#Directory%20versioning">User impact</a>
</ul>
<li><a href="#Compiling%20and%20installing">Compiling and installing</a>
<li><a href="#Quick%20reference%20sheet">Quick reference sheet</a>
<li><a href="#FAQ">FAQ</a>
<li><a href="#Contributing">Contributing</a>
<li><a href="#License">License</a>
</ul>
</ul>

<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next href="#Getting%20Started">Getting Started</a>,
Up:<a rel=up href="#dir">(dir)</a>
<br>

<h2></h2>

<p>This manual is a general guide to the Subversion revision control system.

<ul>
<li><a href="#Getting%20Started">Getting Started</a>:            History, installation and overview of Subversion. 
<li><a href="#Client%20Cookbook">Client Cookbook</a>:            How to use the Subversion client. 
<li><a href="#Repository%20Administration">Repository Administration</a>:  Managing a repository. 
<li><a href="#Appendices">Appendices</a>:                 Other useful documents and pointers. 
</ul>

<p><hr>
Node:<a name="Getting%20Started">Getting Started</a>,
Next:<a rel=next href="#Client%20Cookbook">Client Cookbook</a>,
Previous:<a rel=previous href="#Top">Top</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h2>Getting Started</h2>

<p>How to get started with Subversion.

<ul>
<li><a href="#Introduction">Introduction</a>:                 History and overview of features. 
<li><a href="#Design">Design</a>:                       Overview of system design. 
<li><a href="#Installation">Installation</a>:                 How to obtain Subversion. 
<li><a href="#Basics">Basics</a>:                       Casual description and first-time walk-through. 
</ul>

<p><hr>
Node:<a name="Introduction">Introduction</a>,
Next:<a rel=next href="#Design">Design</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h3>Introduction</h3>

<h4>A Revision Control System</h4>

<p>Subversion is a free/open-source <dfn>revision control system</dfn>.

<p>That is, Subversion manages files over time.  The files are placed into
a central <dfn>repository</dfn>.  The repository is much like an ordinary
file server, except that it remembers every change ever made to your
files.  This allows you to recover older versions of your files, or
browse the history of how your files changed.  Many people think of
revision-control as a sort of "time machine."

<p>Some revision control systems are also <dfn>software configuration
management (SCM)</dfn> systems.  These systems are specifically tailored to
manage trees of source code, and have many features that are specific to
software development (such as natively understanding programming
languages.)  Subversion, however, is not one of these systems; it a
general system that can be used to manage <em>any</em> sort of collection
of files.  (And is still darn good at managing source code.)

<h4>History</h4>

<p>Subversion aims to be the successor to CVS (<a href="http://www.cvshome.org/">http://www.cvshome.org/</a>).

<p>At the time of writing, CVS is the standard Free revision control system
used by the open-source community.  It has a hard-earned, well deserved
reputation as stable and useful software, and has a design that makes it
perfect for open-source development.  However, it also has a number of
problems that are difficult to fix.

<p>Subversion's original designers settled on a few simple goals: it was
decided that Subversion should be a functional replacement for CVS. 
It should do everything that CVS does - preserving the same
development model while fixing the most obvious flaws.  Existing CVS
users are the first target audience: any CVS user should be able to
start using Subversion with little effort.

<p>Collabnet (<a href="http://www.collab.net/">http://www.collab.net/</a>) provided the initial funding
in 2000 to begin development work, and the effort has now blossomed
into a large, open-source project backed by a community of free
software developers.

<h4>Audience</h4>

<p>The intended audience of this book is anyone who has used a revision
control system before, although perhaps not Subversion or CVS.  It
assumes that the reader is computer-literate, and reasonably
comfortable at a Unix command-line.

<p>People familiar with CVS may want to skip some of the introductory
sections that describe Subversion's concurrent versioning model. 
Also, there is a quick guide for CVS users attached as an appendix
(See <a href="#SVN%20for%20CVS%20users">SVN for CVS users</a>.)

<h4>Features</h4>

<p>What sort of things does Subversion do better than CVS?  Here's a short
list to whet your appetite:

<ul>

<li><b>Directory versioning</b> The Subversion repository doesn't use RCS
files like CVS; instead, it implements a "virtual" versioned
filesystem that tracks tree-structures over time.  Files <em>and</em>
directories are versioned.  At last, there are real client-side
`move' and `copy' commands.

<li><b>Atomic commits</b> A commit either goes into the repository
completely, or not all.

<li><b>Advanced network layer</b> The Subversion network server is Apache,
and client and server speak WebDAV protocol to one another.  (see
<a href="#Design">Design</a>)

<li><b>Faster network access</b> A binary diffing algorithm is used to store
and transmit deltas in both directions, regardless of whether a file
is of text or binary type.

<li><b>Meta-data</b> Each file or directory has an invisible hash table
attached.  You can invent and store any arbitrary key/value pairs you
wish: owner, perms, icons, app-creator, mime-type, personal notes,
etc.  This is a general-purpose feature for users.  Properties are
versioned over time, just like file contents.

<li><b>Hackability</b> Subversion has no historical baggage; it is primarily
a collection of shared C libraries with well-defined APIs.  This makes
Subversion extremely maintainable and usable by other applications and
languages.

</ul>

<p><hr>
Node:<a name="Design">Design</a>,
Next:<a rel=next href="#Installation">Installation</a>,
Previous:<a rel=previous href="#Introduction">Introduction</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h3>Design</h3>

<p>Subversion has a modular design; it's implemented as a collection of C
libraries.  Each layer has a well-defined purpose and interface.

<p>If you aren't interested in how Subversion works under the hood, feel
free to skip this section and move on to <a href="#Installation">Installation</a> and
<a href="#Basics">Basics</a>.

<p>Here's a helpful diagram of Subversion's layers.  Program flow begins at
the top of the diagram (initiated by the user) and flows "downward."

<br><pre>                    +--------------------+
                    | commandline or GUI |
                    |    client app      |
         +----------+--------------------+----------+ &lt;=== Client API
         |              Client Library              |
         |                                          |
         |        +----+                            |
         |        |    |                            |
 +-------+--------+    +--------------+--+----------+ &lt;=== Network API
 | Working Copy   |    |    Remote    |  | Local    |
 | Management lib |    | Repos Access |  | Repos    |
 +----------------+    +--------------+  | Access   |
                       |     neon     |  |          |
                       +--------------+  |          |
                          ^              |          |
                         /               |          |
                   DAV  /                |          |
                       /                 |          |
                      v                  |          |
              +---------+                |          |
              |         |                |          |
              | Apache  |                |          |
              |         |                |          |
              +---------+                |          |
              | mod_DAV |                |          |
            +-------------+              |          |
            | mod_DAV_SVN |              |          |
 +----------+-------------+--------------+----------+ &lt;=== Filesystem API
 |                                                  |
 |               Subversion Filesystem              |
 |                                                  |
 +--------------------------------------------------+
</pre>

<h4>Filesystem</h4>

<p>The Subversion Filesystem is not a kernel-level filesystem that one
would install in an operating system (like the Linux ext2 fs.)  Instead,
it refers to the design of Subversion's repository.  The repository is
built on top of a database - currently Berkeley DB - and thus is a
collection of .db files.  However, a library accesses these files and
exports a C API that simulates a filesystem - specifically, a
"versioned" filesystem.

<p>This means that writing a program to access the repository is like
writing against other filesystem APIs: you can open files and
directories for reading and writing as usual.  The main difference is
that this particular filesystem never loses data when written to; old
versions of files and directories are always saved as historical
artifacts.

<p>Using a database backend also provides other nice features that
Subversion needs: data integrity, atomic writes, recoverability, and hot
backups.

<h4>Network Layer</h4>

<p>Subversion has the mark of Apache all over it.  At its very core, the
client uses the Apache Portable Runtime (APR) library.  (This means that
Subversion client compiles and run anywhere Apache httpd does - right
now, this list includes all flavors of Unix, Win32, BeOS, OS/2, Mac OS
X, and possibly Netware.)

<p>However, Subversion depends on more than just APR - the Subversion
"server" is Apache httpd itself.  Apache httpd is a time-tested,
extensible open-source server process that is ready for serious use.  It
can sustain a high network load, runs on many platforms, and can operate
through firewalls.  It can use a number of different authentication
protocols and do network pipelining and caching.  By using Apache as a
server, Subversion gets all these features for free.

<p>Subversion uses WebDAV as its network protocol.  DAV (Distributed
Authoring and Versioning) is a whole discussion in itself (see
<a href="http://www.webdav.org/">http://www.webdav.org/</a>) - but in short, it's an extension to
HTTP that allows reads/writes and "versioning" of files over the web. 
The Subversion project is hoping to ride a slowly rising tide of
support for this protocol: all of the latest file-browsers for Win32,
MacOS, and GNOME speak this protocol already.  Interoperability will
(hopefully) become more and more of a boon over time.

<p>For users who simply wish to access Subversion repositories on local
disk, the client can do this too; no network is required.  The
"Repository Access" layer (RA) is an abstract API implemented by both
the DAV and local-access RA libraries.  This is a specific benefit of
writing a "librarized" revision control system: feel like writing a new
network protocol for Subversion?  Just write a new library that
implements the RA API.

<h4>Client Libraries</h4>

<p>On the client side, the Subversion "working copy" library maintains
administrative information within special .svn subdirectories, similar
in purpose to the CVS administrative directories found in CVS working
copies.

<p>A glance inside the typical .svn directory turns up a bit more than
usual, however.  The `entries' file contains XML which describes the
current state of the working copy directory (and which basically
serves the purposes of CVS's Entries, Root, and Repository files
combined).  But other items present (and not found in CVS) include
storage locations for the versioned "properties" (the metadata
mentioned in "Subversion Features" above) and private caches of
pristine versions of each file.  This latter feature provides the
ability to report local modifications - and do reversions -
<em>without</em> network access.  Authentication data is also stored
within .svn/, rather than in a single .cvspass-like file.

<p>The Subversion "client" library has the broadest responsibility; its job
is to mingle the functionality of the working-copy library with that of
the repository-access library, and then to provide a highest-level API
to any application that wishes to perform general revision control
actions.<a rel=footnote href="#fn-1"><sup>1</sup></a>

<p>The client library is designed to be used by any application.  While the
Subversion source code includes a standard command-line client, it
should be very easy to write any number of GUI clients on top of the
client library.

<p><hr>
Node:<a name="Installation">Installation</a>,
Next:<a rel=next href="#Basics">Basics</a>,
Previous:<a rel=previous href="#Design">Design</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h3>Installation</h3>

<p>### Somebody please write this.  It should describe how to fetch various
binary packages of Subversion for different platforms.  Maybe this
will flesh out once RPMs, .debs, and BSD ports are widely available
from standard locations?

<p>To build from source code, See <a href="#Compiling%20and%20installing">Compiling and installing</a>.

<p><hr>
Node:<a name="Basics">Basics</a>,
Previous:<a rel=previous href="#Installation">Installation</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h3>Basics</h3>

<p>If you're an existing CVS user, then the first section, <a href="#The%20Subversion%20Development%20Model">The Subversion Development Model</a>, should already be familiar.  You may just
want to skim it quickly, noting the special definition of "Revision" in
the second subsection.  At some point, you should probably also read the
appendix which describes fundamental differences between CVS and SVN
(See <a href="#SVN%20for%20CVS%20users">SVN for CVS users</a>.)

<ul>
<li><a href="#The%20Subversion%20Development%20Model">The Subversion Development Model</a>: 
<li><a href="#Quick%20Walkthrough">Quick Walkthrough</a>: 
</ul>

<p><hr>
Node:<a name="The%20Subversion%20Development%20Model">The Subversion Development Model</a>,
Next:<a rel=next href="#Quick%20Walkthrough">Quick Walkthrough</a>,
Up:<a rel=up href="#Basics">Basics</a>
<br>

<h4>The Subversion Development Model</h4>

<ul>
<li><a href="#Working%20Directories%20and%20Repositories">Working Directories and Repositories</a>: 
<li><a href="#Transactions%20and%20Revision%20Numbers">Transactions and Revision Numbers</a>: 
<li><a href="#How%20Working%20Directories%20Track%20the%20Repository">How Working Directories Track the Repository</a>: 
<li><a href="#Subversion%20Does%20Not%20Lock%20Files">Subversion Does Not Lock Files</a>: 
</ul>

<p><hr>
Node:<a name="Working%20Directories%20and%20Repositories">Working Directories and Repositories</a>,
Next:<a rel=next href="#Transactions%20and%20Revision%20Numbers">Transactions and Revision Numbers</a>,
Up:<a rel=up href="#The%20Subversion%20Development%20Model">The Subversion Development Model</a>
<br>

<h5>Working Directories and Repositories</h5>

<p>Suppose you are using Subversion to manage a software project.  There
are two things you will interact with: your working directory, and the
repository.

<p>Your <dfn>working directory</dfn> is an ordinary directory tree, on your
local system, containing your project's sources.  You can edit these
files and compile your program from them in the usual way.  Your working
directory is your own private work area: Subversion never changes the
files in your working directory, or publishes the changes you make
there, until you explicitly tell it to do so.

<p>After you've made some changes to the files in your working directory,
and verified that they work properly, Subversion provides commands to
publish your changes to the other people working with you on your
project.  If they publish their own changes, Subversion provides
commands to incorporate those changes into your working directory.

<p>A working directory contains some extra files, created and maintained by
Subversion, to help it carry out these commands.  In particular, these
files help Subversion recognize which files contain unpublished changes,
and which files are out-of-date with respect to others' work.

<p>While your working directory is for your use alone, the <dfn>repository</dfn>
is the common public record you share with everyone else working on the
project.  To publish your changes, you use Subversion to put them in the
repository.  (What this means, exactly, we explain below.)  Once your
changes are in the repository, others can tell Subversion to incorporate
your changes into their working directories.  In a collaborative
environment like this, each user will typically have their own working
directory (or perhaps more than one), and all the working directories
will be backed by a single repository, shared amongst all the users.

<p>A Subversion repository holds a single directory tree, and records the
history of changes to that tree.  The repository retains enough
information to recreate any prior state of the tree, compute the
differences between any two prior trees, and report the relations
between files in the tree -- which files are derived from which other
files.

<p>A Subversion repository can hold the source code for several projects;
usually, each project is a subdirectory in the tree.  In this
arrangement, a working directory will usually correspond to a particular
subtree of the repository.

<p>For example, suppose you have a repository laid out like this:
<br><pre>/trunk/paint/Makefile
             canvas.c
             brush.c
       write/Makefile
             document.c
             search.c
</pre>

<p>In other words, the repository's root directory has a single
subdirectory named <code>trunk</code>, which itself contains two
subdirectories: <code>paint</code> and <code>write</code>.

<p>To get a working directory, you must <dfn>check out</dfn> some subtree of the
repository.  If you check out <code>/trunk/write</code>, you will get a working
directory like this:
<br><pre>write/Makefile
      document.c
      search.c
      .svn/
</pre>
This working directory is a copy of the repository's <code>/trunk/write</code>
directory, with one additional entry -- <code>.svn</code> -- which holds the
extra information needed by Subversion, as mentioned above.

<p>Suppose you make changes to <code>search.c</code>.  Since the <code>.svn</code>
directory remembers the file's modification date and original contents,
Subversion can tell that you've changed the file.  However, Subversion
does not make your changes public until you explicitly tell it to.

<p>To publish your changes, you can use Subversion's <code>commit</code> command:
<br><pre>$ pwd
/home/jimb/write
$ ls -a
.svn/    Makefile   document.c    search.c
$ svn commit search.c
$
</pre>

<p>Now your changes to <code>search.c</code> have been committed to the
repository; if another user checks out a working copy of
<code>/trunk/write</code>, they will see your text.

<p>Suppose you have a collaborator, Felix, who checked out a working
directory of <code>/trunk/write</code> at the same time you did.  When you
commit your change to <code>search.c</code>, Felix's working copy is left
unchanged; Subversion only modifies working directories at the user's
request.

<p>To bring his working directory up to date, Felix can use the Subversion
<code>update</code> command.  This will incorporate your changes into his
working directory, as well as any others that have been committed since
he checked it out.
<br><pre>$ pwd
/home/felix/write
$ ls -a
.svn/    Makefile    document.c    search.c
$ svn update
U search.c
$
</pre>

<p>The output from the <code>svn update</code> command indicates that Subversion
updated the contents of <code>search.c</code>.  Note that Felix didn't need to
specify which files to update; Subversion uses the information in the
<code>.svn</code> directory, and further information in the repository, to
decide which files need to be brought up to date.

<p>We explain below what happens when both you and Felix make changes to
the same file.

<p><hr>
Node:<a name="Transactions%20and%20Revision%20Numbers">Transactions and Revision Numbers</a>,
Next:<a rel=next href="#How%20Working%20Directories%20Track%20the%20Repository">How Working Directories Track the Repository</a>,
Previous:<a rel=previous href="#Working%20Directories%20and%20Repositories">Working Directories and Repositories</a>,
Up:<a rel=up href="#The%20Subversion%20Development%20Model">The Subversion Development Model</a>
<br>

<h5>Transactions and Revision Numbers</h5>

<p>A Subversion <code>commit</code> operation can publish changes to any number
of files and directories as a single atomic transaction.  In your
working directory, you can change files' contents, create, delete,
rename and copy files and directories, and then commit the completed set
of changes as a unit.

<p>In the repository, each commit is treated as an atomic transaction:
either all the commit's changes take place, or none of them take place. 
Subversion tries to retain this atomicity in the face of program
crashes, system crashes, network problems, and other users' actions.  We
may call a commit a <dfn>transaction</dfn> when we want to emphasize its
indivisible nature.

<p>Each time the repository accepts a transaction, this creates a new state
of the tree, called a <dfn>revision</dfn>.  Each revision is assigned a unique
natural number, one greater than the number of the previous revision. 
The initial revision of a freshly created repository is numbered zero,
and consists of an empty root directory.

<p>Unlike those of many other systems, Subversion's revision numbers apply
to an entire tree, not individual files.  Each revision number selects an
entire tree.

<p>It's important to note that working directories do not always correspond
to any single revision in the repository; they may contain files from
several different revisions.  For example, suppose you check out a
working directory from a repository whose most recent revision is 4:
<br><pre>write/Makefile:4
      document.c:4
      search.c:4
</pre>

<p>At the moment, this working directory corresponds exactly to revision 4
in the repository.  However, suppose you make a change to
<code>search.c</code>, and commit that change.  Assuming no other commits have
taken place, your commit will create revision 5 of the repository, and
your working directory will look like this:
<br><pre>write/Makefile:4
      document.c:4
      search.c:5
</pre>
Suppose that, at this point, Felix commits a change to
<code>document.c</code>, creating revision 6.  If you use <code>svn update</code> to
bring your working directory up to date, then it will look like this:
<br><pre>write/Makefile:6
      document.c:6
      search.c:6
</pre>
Felix's changes to <code>document.c</code> will appear in your working copy of
that file, and your change will still be present in <code>search.c</code>.  In
this example, the text of <code>Makefile</code> is identical in revisions 4, 5,
and 6, but Subversion will mark your working copy with revision 6 to
indicate that it is still current.  So, after you do a clean update at
the root of your working directory, your working directory will
generally correspond exactly to some revision in the repository.

<p><hr>
Node:<a name="How%20Working%20Directories%20Track%20the%20Repository">How Working Directories Track the Repository</a>,
Next:<a rel=next href="#Subversion%20Does%20Not%20Lock%20Files">Subversion Does Not Lock Files</a>,
Previous:<a rel=previous href="#Transactions%20and%20Revision%20Numbers">Transactions and Revision Numbers</a>,
Up:<a rel=up href="#The%20Subversion%20Development%20Model">The Subversion Development Model</a>
<br>

<h5>How Working Directories Track the Repository</h5>

<p>For each file in a working directory, Subversion records two essential
pieces of information:
<ul>
<li>what revision of what repository file your working copy is based on
(this is called the file's <dfn>working revision</dfn>), and
<li>a timestamp recording when the local copy was last updated by the repository. 
</ul>

<p>Given this information, by talking to the repository, Subversion can
tell which of the following four states a file is in:
<ul>
<li><b>Unchanged, and current.</b>  The file is unchanged in the working
directory, and no changes to that file have been committed to the
repository since its base revision. 
<li><b>Locally changed, and current</b>.  The file has been changed in the
working directory, and no changes to that file have been committed to
the repository since its base revision.  There are local changes that
have not been committed to the repository. 
<li><b>Unchanged, and out-of-date</b>.  The file has not been changed in the
working directory, but it has been changed in the repository.  The file
should eventually be updated, to make it current with the public
revision. 
<li><b>Locally changed, and out-of-date</b>.  The file has been changed both
in the working directory, and in the repository.  The file should be
updated; Subversion will attempt to merge the public changes with the
local changes.  If it can't complete the merge in a plausible way
automatically, Subversion leaves it to the user to resolve the conflict. 
</ul>

<p>The subversion <code>status</code> command will show you the state of any item in
your working copy.  See <a href="#Basic%20Work%20Cycle">Basic Work Cycle</a>, in particular the
subsection "Examine your changes".

<p><hr>
Node:<a name="Subversion%20Does%20Not%20Lock%20Files">Subversion Does Not Lock Files</a>,
Previous:<a rel=previous href="#How%20Working%20Directories%20Track%20the%20Repository">How Working Directories Track the Repository</a>,
Up:<a rel=up href="#The%20Subversion%20Development%20Model">The Subversion Development Model</a>
<br>

<h5>Subversion Does Not Lock Files</h5>

<p>Subversion does not prevent two users from making changes to the same
file at the same time.  For example, if both you and Felix have checked
out working directories of <code>/trunk/write</code>, Subversion will allow
both of you to change <code>write/search.c</code> in your working directories. 
Then, the following sequence of events will occur:
<ul>
<li>Suppose Felix tries to commit his changes to <code>search.c</code> first.  His
commit will succeed, and his text will appear in the latest revision in
the repository. 
<li>When you attempt to commit your changes to <code>search.c</code>, Subversion
will reject your commit, and tell you that you must update
<code>search.c</code> before you can commit it. 
<li>When you update <code>search.c</code>, Subversion will try to merge Felix's
changes from the repository with your local changes.  By default,
Subversion merges as if it were applying a patch: if your local changes
do not overlap textually with Felix's, then all is well; otherwise,
Subversion leaves it to you to resolve the overlapping
changes.  In either case,
Subversion carefully preserves a copy of the original pre-merge text. 
<li>Once you have verified that Felix's changes and your changes have been
merged correctly, you can commit the new revision of <code>search.c</code>,
which now contains everyone's changes. 
</ul>

<p>Some revision control systems provide "locks", which prevent others
from changing a file once one person has begun working on it.  In our
experience, merging is preferable to locks, because:
<ul>
<li>changes usually do not conflict, so Subversion's behavior does the right
thing by default, while locking can interfere with legitimate work;
<li>locking can prevent conflicts within a file, but not conflicts between
files (say, between a C header file and another file that includes it),
so it doesn't really solve the problem; and finally,
<li>people often forget that they are holding locks, resulting in
unnecessary delays and friction. 
</ul>

<p>Of course, the merge process needs to be under the users' control. 
Contextual, line-by-line patching is not appropriate for files with
rigid formats, like images or executables.  Subversion attempts to
notice when a file is in a binary format, or is of any mime-type other
than text/*.  For these rigid-format files, Subversion simply presents
you with the two original texts to choose from.  See <a href="#Basic%20Work%20Cycle">Basic Work Cycle</a>, in particular the subsection "Merge others' changes".

<p><hr>
Node:<a name="Quick%20Walkthrough">Quick Walkthrough</a>,
Previous:<a rel=previous href="#The%20Subversion%20Development%20Model">The Subversion Development Model</a>,
Up:<a rel=up href="#Basics">Basics</a>
<br>

<h4>Quick Walkthrough</h4>

<p>The previous section gave an abstract overview of the Subversion
development model.  Here's an opportunity to play with Subversion in
some hands-on examples.  The Subversion commands demoed here are just
small examples of what Subversion can do; see Chapter 2 for full
explanations of each.

<ul>
<li><a href="#Make%20a%20repository">Make a repository</a>: 
<li><a href="#Make%20some%20working%20copies">Make some working copies</a>: 
</ul>

<p><hr>
Node:<a name="Make%20a%20repository">Make a repository</a>,
Next:<a rel=next href="#Make%20some%20working%20copies">Make some working copies</a>,
Up:<a rel=up href="#Quick%20Walkthrough">Quick Walkthrough</a>
<br>

<h5>Make a repository</h5>

<p>The Subversion client has an abstract interface for accessing a
repository.  Two "Repository Access" (RA) implementations currently
exist as libraries.  You can see which methods are available to your svn
client like so:

<br><pre>$ svn --version
Subversion Client, version N
compiled Jan 26 2002, 16:43:58

Copyright (C) 2000-2002 CollabNet.
Subversion is open source software, see <a href="http://subversion.tigris.org/">http://subversion.tigris.org/</a>

The following repository access (RA) modules are available:

* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.
     - handles 'http' schema
* ra_local : Module for accessing a repository on local disk.
     - handles 'file' schema
</pre>

<p>If you don't see ra_local, it probably means that Berkeley DB (or
relevant database back-end) wasn't found when compiling your client
binary.  To continue with these examples, you'll need to have ra_local
available.

<p>Start by creating a new, empty repository using the <code>svnadmin</code>
tool:

<br><pre>$ svnadmin create myrepos
</pre>

<p>Let's assume you have a directory <code>someproject</code> which contains
files that you wish to place under version control:

<br><pre>someproject/foo
            bar
            baz/
            baz/gloo
            baz/bloo
</pre>

<p>Once the repository exists, you can initially import your data into it,
using the ra_local access method (invoked by using a "file" URL):

<br><pre>$ svn import file:///absolute/path/to/myrepos someproject myproj
[...]
Committed revision 1.
</pre>

<p>The example above creates a new directory <code>myproj</code> in the root of
the repository's filesystem, and copies all the data from
<code>someproject</code> into it.

<p><hr>
Node:<a name="Make%20some%20working%20copies">Make some working copies</a>,
Previous:<a rel=previous href="#Make%20a%20repository">Make a repository</a>,
Up:<a rel=up href="#Quick%20Walkthrough">Quick Walkthrough</a>
<br>

<h5>Make some working copies</h5>

<p>Now check out a fresh "working copy" of your project.  To do this, we
specify a URL to the exact directory within the repository that we want. 
The parameter after the URL allows us to name the working copy we check out.

<br><pre>$ svn co file:///usr/local/svn/repos/myproj wc
A  wc/foo
A  wc/bar
A  wc/baz
A  wc/baz/gloo
A  wc/baz/bloo
</pre>

<p>Now we have a working copy in a local directory called <code>wc</code>, which
represents the location <code>/myproj</code> in the repository (assuming the
repository's root is &lt;<code>file:///usr/local/svn/repos</code>&gt;.)

<p>For the sake of example, let's duplicate the working copy, and pretend
it belongs to someone else:

<br><pre>$ cp -R wc wc2
</pre>

<p>From here, let's make some changes within our original working copy:

<br><pre>$ cd wc
$ echo "new text" &gt;&gt; bar       # change bar's text
$ svn propset color green foo  # add a metadata property to foo
$ svn rm baz                   # schedule baz directory for deletion
$ touch newfile
$ svn add newfile              # schedule newfile for addition
</pre>

<p>That's a lot of changes!  If we were to leave and come back tomorrow,
how could we remember what changes we'd made?  Easy.  The <code>status</code>
command will show us all of the "local modifications" in our working
copy:

<br><pre>$ svn status                   # See what's locally modified
M   ./bar
_M  ./foo
A   ./newfile
D   ./baz
D   ./baz/gloo
D   ./baz/bloo
</pre>

<p>According to this output, three items are scheduled to be (D)eleted from
the repository, one item is scheduled to be (A)dded to the repository,
and two items have had their contents (M)odified in some way.  For more
details, be sure to read about <code>svn status</code> in Chapter 2.

<p>Now we decide to commit our changes, creating Revision 2 in the
repository:

<br><pre>$ svn commit -m "fixed bug #233"
Sending    bar
Sending    foo
Adding     newfile
Deleting   baz
Transmitting data...
Committed revision 2.
</pre>

<p>The -m argument is a way of specifying a <dfn>log message</dfn>: that is, a
specific description of your change-set sent to the repository.  The log
message is now attached to Revision 2.  A future user might peruse
repository log messages, and now will know what your Revision 2 changes
were for.

<p>Finally, pretend that you are now Felix, or some other collaborator.  If
you go <code>wc2</code> (that other working copy you made), it will need the
<code>svn update</code> command to receive the Revision 2 changes:

<br><pre>   $ cd ../wc2                # change to the back-up working copy

   $ svn update               # get changes from repository
   U   ./bar
   _U  ./foo
   A   ./newfile
   D   ./baz
</pre>

<p>The output of the <code>svn update</code> command tells Felix that baz was
(D)eleted from his working copy, newfile was (A)dded to his working
copy, and that bar and foo had their contents (U)pdated.

<p>If for some reason <code>bar</code> contained some local changes made by
Felix, then the server changes would be <dfn>merged</dfn> into <code>bar</code>:
that is, <code>bar</code> would now contain both sets of changes.  Whenever
server changes are merged into a locally-modified file, two possible
things can happen:

<ul>
<li>The merge can go smoothly.  That is, the two sets of changes do not
overlap.  In this case, <code>svn update</code> prints a <code>G</code> ("mer(G)ed"). 
<li>The sets of changes overlap, and a <code>C</code> for (C)onflict is printed.  See
section ??? for information about how conflict resolution works. 
</ul>

<p><hr>
Node:<a name="Client%20Cookbook">Client Cookbook</a>,
Next:<a rel=next href="#Repository%20Administration">Repository Administration</a>,
Previous:<a rel=previous href="#Getting%20Started">Getting Started</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h2>Client Cookbook</h2>

<p>How to make a lovely gumbo with your Subversion client, in 11 easy steps.

<p>This chapter goes into more of the gritty details of client commands. 
For a first overview of the the client's CVS-like
"copy-modify-merge" model of development, See <a href="#Basics">Basics</a>.

<p>Before reading on, here is the most important piece of information
you'll ever need when using Subversion: <code>svn help</code>.  The
Subversion command-line client tries to be self-documenting; at any
time, a quick <code>svn help &lt;subcommand&gt;</code> will describe the
syntax, switches, and behavior of <code>subcommand</code>.

<p>This chapter by no means covers every option to every client
subcommand.  Instead, it's a conversational introduction to the most
common tasks you'll encounter.  When in doubt, run <code>svn help</code>.

<ul>
<li><a href="#Checkout">Checkout</a>: 
<li><a href="#Basic%20Work%20Cycle">Basic Work Cycle</a>: 
<li><a href="#History">History</a>: 
<li><a href="#Branches%20and%20Tags">Branches and Tags</a>: 
<li><a href="#Properties">Properties</a>: 
<li><a href="#Modules">Modules</a>: 
<li><a href="#Revisions">Revisions</a>: 
<li><a href="#Other%20Commands">Other Commands</a>: 
<li><a href="#Run-time%20Configuration">Run-time Configuration</a>: 
</ul>

<p><hr>
Node:<a name="Checkout">Checkout</a>,
Next:<a rel=next href="#Basic%20Work%20Cycle">Basic Work Cycle</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>Checkout</h3>

<p>Most of the time, you will start using a Subversion repository by
doing a <dfn>checkout</dfn> of your project.  "Checking out" will provide
you with a local copy of the HEAD (latest revision) of the Subversion
repository that you checked out.

<br><pre>$ svn co http://svn.collab.net/repos/svn/trunk
A  trunk/subversion.dsw
A  trunk/svn_check.dsp
A  trunk/COMMITTERS
A  trunk/configure.in
A  trunk/IDEAS
...
Checked out revision 2499.
</pre>

<p>Although the above example checks out the trunk directory, you can just
as easily checkout any deep subdirectory of a repository by specifying
the subdirectory in the checkout URL:

<br><pre>$ svn co http://svn.collab.net/repos/svn/trunk/doc/handbook
A  handbook/svn-handbook.texi
A  handbook/getting_started.texi
A  handbook/outline.txt
A  handbook/license.texi
A  handbook/repos_admin.texi
A  handbook/client.texi
Checked out revision 2499.
</pre>

<p>Since Subversion uses a "copy-modify-merge" model instead of
"lock-modify-unlock", you're now ready to start making changes to
the files that you've checked out, known collectively as your
<dfn>working copy</dfn>. You can even delete the entire working copy and
forget about it entirely - there's no need to notify the Subversion
server unless you're ready to <dfn>check in</dfn> changes, a new file, or
even a directory.

<p>Every directory in a working copy contains an <dfn>administrative
area</dfn>, a subdirectory named <code>.svn</code>.  Normal <code>ls</code> commands
won't show this subdirectory, but it's vital.  Whatever you do, don't
delete or change anything in the administrative area!  Subversion
depends on it to manage your working copy.

<p>You can run <code>svn help checkout</code> for command line options to
checkout, although one option is very common and worth mentioning: you
can specify a directory after your repository url.  This places your working
copy into a new directory that you name.  For example:

<br><pre>$ svn co http://svn.collab.net/repos/svn/trunk subv
A  subv/subversion.dsw
A  subv/svn_check.dsp
A  subv/COMMITTERS
A  subv/configure.in
A  subv/IDEAS
...
Checked out revision 2499.
</pre>

<p><hr>
Node:<a name="Basic%20Work%20Cycle">Basic Work Cycle</a>,
Next:<a rel=next href="#History">History</a>,
Previous:<a rel=previous href="#Checkout">Checkout</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>Basic Work Cycle</h3>

<p>Subversion has numerous features, options, bells and whistles, but on
a day-to-day basis, odds are that you will only use a few of them. In
this section we'll run through the most common things that you might
find yourself doing with Subversion in the course of a day's work.

<p>The typical work cycle looks like this:

<ul>
<li>Update your working copy
<li>Make changes
<li>Examine your changes
<li>Merge others' changes
<li>Commit your changes
</ul>

<h4>Update your working copy (<code>svn up</code>)</h4>

<p>When working on a project with a team, you'll want to <dfn>update</dfn>
your working copy: that is, receive any changes from other developers
on the project.  <code>svn update</code> brings your working copy in-sync
with the latest revision in the repository.

<br><pre>$ svn up
U  ./foo.c
U  ./bar.c
Updated to revision 2.
</pre>

<p>In this case, someone else checked in modifications to both
<code>foo.c</code> and <code>bar.c</code> since the last time you updated, and
Subversion has updated your working copy to include those changes.

<p>Let's examine the output of <code>svn update</code> a bit more.  When the
server sends changes to your working copy, a letter code is displayed
next to each item:

<dl>
<dt><b>U  foo</b>
<dd>File <code>foo</code> was (U)pdated (received changes from the server.) 
<br><dt><b>A  foo</b>
<dd>File or directory <code>foo</code> was (A)dded to your working copy. 
<br><dt><b>D  foo</b>
<dd>File or directory <code>foo</code> was (D)eleted from your working copy. 
<br><dt><b>R  foo</b>
<dd>File or directory <code>foo</code> was (R)eplaced in your working copy;
that is, <code>foo</code> was deleted, and a new item with the same name
was added.  While they may have the same name, the repository
considers them to be distinct objects with distinct histories. 
<br><dt><b>G  foo</b>
<dd>File <code>foo</code> received new changes, but also had changes of your own
to begin with.  The changes did not intersect, however, so Subversion
has mer(G)ed the repository's changes into the file without a problem. 
<br><dt><b>C  foo</b>
<dd>File <code>foo</code> received (C)onflicting changes from the server.  The
changes from the server directly overlap your own changes to the file. 
No need to panic, though.  This overlap needs to be resolved by a
human (you); we discuss this situation further down. 
</dl>

<h4>Make changes  (<code>svn add</code>, <code>svn rm</code>, <code>svn cp</code>, <code>mv</code>)</h4>

<p>Now you can to get to work and make changes in your working copy. It's
usually most convenient to create a "task" for yourself, such as
writing a new feature, fixing a bug, etc.

<p>What kinds of changes can you make to your working copy tree?

<dl>
<dt><b>File changes</b>
<dd>This is the simplest sort of change.  Unlike other revision control
systems, you don't need to tell Subversion that you intend to change a
file; just do it.  Later on, Subversion will be able to automatically
detect which files have been changed. 
<br><dt><b>Tree changes</b>
<dd>You can ask Subversion to "mark" files and directories for scheduled
removal or addition.  Of course, no additions or removals will happen
in the repository until you decide to commit. 
</dl>

<p>To make file changes, just use your normal editor, word processor, or
whatever.   A file needn't be in text-format; binary files work just
fine.

<p>There are at least four Subversion subcommands for making tree
changes.  Detailed help can be found with <code>svn help</code>, but here
is an overview:

<dl>
<dt><code><code>svn add <code>foo</code></code></code>
<dd>Schedule <code>foo</code> to be added to the repository.  When you next
commit, <code>foo</code> will become a permanent child of its parent
directory.  Note that if <code>foo</code> is a directory, only the directory
itself will be scheduled for addition.  If you want to add its
contents as well, pass the <code>--recursive</code> switch. 
<br><dt><code><code>svn rm <code>foo</code></code></code>
<dd>Schedule <code>foo</code> to be removed from the repository.  If <code>foo</code>
is a file, it immediately vanishes from the working copy - but it can
be recovered with <code>svn revert</code> (see below).  If <code>foo</code> is
a directory, it is merely scheduled for deletion.  After you commit,
<code>foo</code> will no longer exist in the working copy or repository. 
<br><dt><code><code>svn cp <code>foo</code> <code>bar</code></code></code>
<dd>Create new item <code>bar</code> as a duplicate of <code>foo</code>.  <code>bar</code>
is automatically scheduled for addition.  When <code>bar</code> is added to
the repository on the next commit, it's copy-history is recorded (as
having originally come from <code>foo</code>.) 
<br><dt><code><code>svn mv <code>foo</code> <code>bar</code></code></code>
<dd>This command is exactly the same as running <code>svn cp foo bar;
svn rm foo</code>.  That is, <code>bar</code> is scheduled for addition as a copy
of <code>foo</code>, and <code>foo</code> is scheduled for removal. 
</dl>

<p>Let's ammend our original statement: there <em>are</em> some use-cases
that immediately commit tree changes to the repository.  This usually
happens when a subcommand is operating directly on a URL, rather than
on a working-copy path. (In particular, specific uses of <code>svn
mkdir</code>, <code>svn cp</code>, <code>svn mv</code>, and <code>svn rm</code> can work with
URLs.  See <code>svn help</code> on these commands for more details.)

<h4>Examine your changes  (<code>svn status</code>, <code>svn diff</code>, <code>svn revert</code>)</h4>

<p>So now you've finished your changes... or so you think.  But what
exactly did you change?  How can you review them?

<p>Subversion has been optimized to help you with this task, and is able
to do many things without talking to the repository or network at all. 
In particular, your working copy contains a secret cached "pristine"
copy of each file within the <code>.svn</code> area.  Because of this, it
can quickly show you how your working files have changed, or even
allow you to undo your changes.

<p>The <code>svn status</code> command is your friend; become intimate with
it.  You'll probably use <code>svn status</code> more than any other
command.

<p>If you run <code>svn status</code> at the top of your working copy, with
no arguments, it will detect all file and tree changes you've made:

<br><pre>$ svn status
M      ./bar.c
M      ./README
D      ./stuff/fish.c
A      ./stuff/things/bloo.h
</pre>

<p>Here, the status command is saying that you have (M)odified two files,
scheduled another for (A)ddition, and scheduled another for (D)eletion.

<p>If a single path is passed to the command, it will tell you about it:

<br><pre>$ svn status stuff/fish.c
D      ./stuff/fish.c
</pre>

<p>This command also has a <code>--verbose</code> (<code>-v</code>) mode, which will
show you the status of <em>every</em> item in your working copy:

<br><pre>$ svn status -v
M               44        23    joe       ./README
_               44        30    frank     ./INSTALL
M               44        20    frank     ./bar.c
_               44        18    joe       ./stuff
_               44        35    mary      ./stuff/trout.c
D               44        19    frank     ./stuff/fish.c
_               44        21    mary      ./stuff/things
A                0         ?     ?        ./stuff/things/bloo.h
_               44        36    joe       ./stuff/things/gloo.c
</pre>

<p>This is the "long form" output of <code>svn status</code>.  The first
column is still the same.  The second column shows the
working-revision of the item.  The third and fourth column show the
revision in which the item last changed, and who changed it.

<p>Finally, there is a <code>--show-updates</code> (<code>-u</code>) switch, which
contacts the repository and adds information about things that are
out-of-date:

<br><pre>$ svn status -u -v
M      *        44        23    joe       ./README
M               44        20    frank     ./bar.c
_      *        44        35    mary      ./stuff/trout.c
D               44        19    frank     ./stuff/fish.c
A                0         ?     ?        ./stuff/things/bloo.h
</pre>

<p>Notice the two asterisks: if you were to run <code>svn up</code> at this
point, you would receive changes to <code>README</code> and <code>trout.c</code>. 
Hmmm, better be careful.  You'll need to absorb those server-changes
on <code>README</code> before you commit, lest the repository reject your
commit for being out-of-date.  (More on this subject below.)

<p>We should also mention two other status codes that you might see:

<br><pre>$ svn status
?    ./foo.o
!    ./foo.c
</pre>

<p>The <code>?</code> indicates a file in the directory that is not under revision
control.  You can silence the question marks by either passing the
<code>--quiet</code> (<code>-q</code>) option to status, or by setting the
<code>svn:ignore</code> property on the parent directory
(See <a href="#Properties">Properties</a>.   The <code>!</code> indicates that the file is under
revision control, but the working file is missing.  A quick
<code>svn up</code> or <code>svn revert foo.c</code> will restore the
missing file from its cached pristine copy.

<p>Another way to examine your changes is with the <code>svn diff</code>
command.  You can find out <em>exactly</em> how you've modified things
by running <code>svn diff</code> with no arguments, which prints out file
changes in unified diff format:

<br><pre>$ svn diff
Index: ./bar.c
===================================================================
--- ./bar.c
+++ ./bar.c	Mon Jul 15 17:58:18 2002
@ -1,7 +1,12 @
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

 int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
   return 0;
 }

Index: ./README
===================================================================
--- ./README
+++ ./README	Mon Jul 15 17:58:18 2002
@ -193,3 +193,4 @
+Note to self:  pick up laundry.

Index: ./stuff/fish.c
===================================================================
--- ./stuff/fish.c
+++ ./stuff/fish.c  Mon Jul 15 17:58:18 2002
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: ./stuff/things/bloo.h
===================================================================
--- ./stuff/things/bloo.h
+++ ./stuff/things/bloo.h  Mon Jul 15 17:58:18 2002
+Here is a new file to describe
+things about bloo.
</pre>

<p>The <code>svn diff</code> command produces this output by comparing your
working files against the cached "pristine" copies within the
<code>.svn</code> area.  Files scheduled for addition are displayed as all
added-text, and files scheduled for deletion are displayed as all
deleted text.

<p>Now suppose you see this output, and realize that your changes to
<code>README</code> are a mistake; perhaps you accidentally typed that text
into the wrong file in your editor.

<p>The <code>svn revert</code> command is exactly for this purpose.  It
throws away all changes to your file:

<br><pre>$ svn revert README
Reverted ./README
</pre>

<p>The file is reverted to its pre-modified state by overwriting it with
the cached "pristine" copy.  But also note that <code>svn revert</code>
can undo any scheduled operations - in case you decide that you don't
want to add a new file after all, or that you don't want to remove
something.

<p>A final reminder: all three of these commands (<code>svn status</code>,
<code>svn diff</code>, <code>svn revert</code>) can be used without any
network access (except for the <code>-u</code> switch to status).  This
makes it easy to manage your changes-in-progress while traveling on
an airplane, etc.

<h4>Merge others' changes  (conflict resolution)</h4>

<p>We've already seen how <code>svn status -u</code> can predict conflicts. 
Suppose you run <code>svn update</code> and some interesting things
occur:

<br><pre>$ svn up
U  ./INSTALL
G  ./README
C  ./bar.c
</pre>

<p>The U and G codes are nothing to sweat about; those files cleanly
absorbed changes from the repository.  The <code>G</code> stands for mer(G)ed,
which means that the file had local changes to begin with, but the
repository changes didn't overlap in any way.

<p>But the <code>C</code> stands for conflict.  This means that the server's changes
overlapped with your own, and now you have to manually choose between
them.

<p>Whenever a conflict occurs:

<ul>
<li>a <code>C</code> is printed during the update, and Subversion remembers that the
file is "conflicted". 
<li>three fulltext files starting with <code>tmp</code> are created; these files
are the original three files that could not be merged together. 
<li>conflict markers are placed into the file, to visibly demonstrate the
overlapping areas. 
</ul>

<p>At this point, Subversion will <em>not</em> allow you to commit the file
until the three temporary files are removed.

<p>If you get a conflict, you need to either (1) hand-merge the
conflicted text (by examining and editing the conflict markers within
the file), (2) copy one of the tmpfiles on top of your working file, or
(3) run <code>svn revert</code> to toss all of your changes.

<p>Once you've resolved the conflict, you need to let Subversion know by
removing the three tmpfiles.  (The <code>svn resolve</code> command, by
the way, is a shortcut that does nothing but automatically remove the
three tmpfiles for you.)  When the tmpfiles are gone, Subversion no
longer considers the file to be in a state of conflict anymore.

<h4>Commit your changes</h4>

<p>Finally!  Your edits are finished, you've merged all updates from the
server, and you're ready to commit your changes.

<p>The <code>svn commit</code> command sends all (or some) of your changes
to the repository.  When you commit a change, you need to supply a
<dfn>log message</dfn>, describing your change.  Your log message will be
permanently attached to the new revision you create.

<br><pre>$ svn commit -m "Added include lines and corrected # of cheese slices."
Sending        bar.c
Transmitting file data .
Committed revision 3.
$
</pre>

<p>Another way to specify a log message is to place it in a file, and
pass the filename with the <code>-F</code> switch.  If you fail to
specify either the <code>-m</code> or <code>-F</code> switch, then Subversion will
automatically launch your favorite <code>$EDITOR</code> for composing a log
message.

<p>The repository doesn't know or care if your changes make any sense as
a whole; it only checks to make sure that nobody else has changed any
of the same files that you did when you weren't looking.  If somebody
<em>has</em> done that, the entire commit will fail with a message
informing that one or more of your files is out-of-date.  At this
point, you need to run <code>svn update</code> again, deal with any
merges or conflicts that result, and attempt your commit again.

<p>That covers the most basic work cycle for using Subversion. Run
<code>svn help <var>commandname</var></code> for help on any of the commands
covered in this section.

<p><hr>
Node:<a name="History">History</a>,
Next:<a rel=next href="#Branches%20and%20Tags">Branches and Tags</a>,
Previous:<a rel=previous href="#Basic%20Work%20Cycle">Basic Work Cycle</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>History</h3>

<p>As we mentioned earlier, the repository is like a time machine.  It
remembers every revision ever committed, and allows you to explore
this history.

<p>There are two commands that mine historical data from the repository. 
<code>svn log</code> shows you broad information: log messages attached
to revisions, and which paths changed in each revision.  <code>svn
diff</code>, on the other hand, can show you the specific details of how a
file changed over time.

<h4><code>svn log</code></h4>

<p>To find out information about the history of a file or directory, you
use the <code>svn log</code> command. <code>svn log</code> will tell you who
made changes to a file and at what revision, the time and date of that
revision, and the log message that accompanied the commit.

<br><pre>$ svn log
------------------------------------------------------------------------
rev 3:  fitz | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
rev 2:  someguy | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line

Added main() methods.
------------------------------------------------------------------------
rev 1:  fitz | Mon, 15 Jul 2002 17:40:08 -0500 | 2 lines

Initial import
------------------------------------------------------------------------
</pre>

<p>Note that the log messages are printed in reverse chronological order
by default.  If you wish to see a different range of revisions in a
particular order, or just a single revision, pass the
<code>--revision</code> (<code>-r</code>) switch:

<br><pre>$ svn log -r 5:19
[...]  # shows logs 5 through 19 in chronological order
$ svn log -r 19:5
[...]  # shows logs 5 through 19 in reverse order
$ svn log -r 8
[...]
</pre>

<p>You can also examine the log history on a single file or directory. 
The commands

<br><pre>$ svn log foo.c
[...]
$ svn log http://foo.com/svn/trunk/code/foo.c
[...]
</pre>

<p>will display log messages <em>only</em> for those revisions in which the
working file (or URL) changed.

<p>And while we're on the subject, <code>svn log</code> also takes a
<code>--verbose</code> (<code>-v</code>) option too; it includes a list of
changed-paths in each revision:

<br><pre>$ svn log -r 8 -v
------------------------------------------------------------------------
rev 8:  jrandom | 2002-07-14 08:15:29 -0500 | 1 line
Changed paths:
   U /trunk/code/foo.c
   U /trunk/code/bar.h
   A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
</pre>

<h4><code>svn diff</code></h4>

<p>We've already seen <code>svn diff</code> in an previous section; it
displays file differences in unified diff format.  Earlier, it was
used to show the local modifications made to our working copy.

<p>In fact, it turns out that there are <em>three</em> distinct uses of
<code>svn diff</code>:

<h5>Examining local changes</h5>

<p>Invoking <code>svn diff</code> with no switches will compare your working
files to the cached "pristine" copies in the <code>.svn</code> area:

<br><pre>$ svn diff foo
Index: ./foo
===================================================================
--- ./foo
+++ ./foo	Tue Jul 16 15:19:53 2002
@ -1 +1,2 @
 An early version of the file
+...extra edits
</pre>

<h5>Comparing working copy to repository</h5>

<p>If a single <code>--revision</code> (<code>-r</code>) number is passed, then your
working files are compared to a particular revision in the repository.

<br><pre>$ svn diff -r 3 foo
Index: ./foo
===================================================================
--- ./foo
+++ ./foo	Tue Jul 16 15:19:53 2002
@ -1,2 +1,2 @
 An early version of the file
-Second version of the file
+...extra edits
</pre>

<h5>Comparing repository to repository</h5>

<p>If two revision numbers are passed via <code>-r</code>, then the two
revisions are directly compared.

<br><pre>$ svn diff -r 2:3 foo

Index: ./foo
===================================================================
--- ./foo
+++ tmp.280.00001	Tue Jul 16 15:22:19 2002
@ -1 +1,2 @
 An early version of the file
+Second version of the file
</pre>

<p>If you read the help for <code>svn diff</code>, you'll discover that you
can supply URLs instead of working copy paths as well.  This is
especially useful if you wish to inspect changes when you have no
working copy available:

<br><pre>$ svn diff -r 23:24 http://foo.com/some/project
[...]
</pre>

<p><hr>
Node:<a name="Branches%20and%20Tags">Branches and Tags</a>,
Next:<a rel=next href="#Properties">Properties</a>,
Previous:<a rel=previous href="#History">History</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>Branches and Tags</h3>

<p>Branches and tags are general concepts common to almost all revision
control systems.  If you're not familiar with these ideas, you can
find a good introductory explanation in Karl Fogel's free CVS
book: <a href="http://cvsbook.red-bean.com/cvsbook.html#Branching_Basics">http://cvsbook.red-bean.com/cvsbook.html#Branching_Basics</a>

<p>At this point, you should understand how each commit creates an entire
new filesystem tree in the repository.  (If not, read about
<dfn>revisions</dfn>, See <a href="#Transactions%20and%20Revision%20Numbers">Transactions and Revision Numbers</a>, or
See <a href="#Revision%20numbers%20are%20different%20now">Revision numbers are different now</a>.)

<p>As you may have suspected, the filesystem doesn't grow 652 new inodes
each time a new revision is created.  Instead, each new tree is
<em>mostly</em> made of pointers to already-existing nodes; new nodes
are created only for changed items, and all the rest of the revision
tree is "shared storage" with other revision trees.  This technique
demonstrates how the filesystem is able to make "cheap copies" of
things.  These cheap copies are nothing more than directory entries
that point to existing nodes.  And this is the basis of tags and
branches.

<h4>Branching with <code>svn cp</code></h4>

<p>Suppose we have a repository whose head tree is revision 82.  In this
repository is a subdirectory <code>mooIRC</code> that contains a software
project that is ready to be tagged.  How do we tag it?  Very simple:
make a "cheap" copy of this directory.  In other words, create a new
directory entry (somewhere else in the filesystem) that points to this
<em>specific</em> node that represents directory <code>mooIRC</code> in
revision 82.  Of course, you can name the new directory entry whatever
you want - probably a tag-name like <code>mooIRC-beta</code>.

<p>The easiest way to make this copy is with <code>svn cp</code>, which,
incidentally, can operate entirely on URLs, so that the copy happens
only on the server-side:

<br><pre>$ svn cp http://foo.com/repos/mooIRC \
         http://foo.com/repos/mooIRC-beta
Committed revision 83.
</pre>

<p>Now, as long as you never touch the contents of the directory
<code>mooIRC-beta</code>, that entry will forever point to a node that looks
the way <code>mooIRC</code> did at a specific moment in time (however it
looked in revision 82).  And that's exactly what a <dfn>tag</dfn> is.

<p>But suppose <code>mooIRC-beta</code> isn't sacred, and instead you decide to
start making commits to it.  And suppose you <em>also</em> continue to
make commits in the original <code>mooIRC</code> directory.  Then you have
two directories that started out looking identical - their common
ancestor was <code>mooIRC</code> in revision 82 - but now have diverged
their contents over time.  In other words, they represent different
<dfn>branches</dfn> of the project.

<p>It's very important to note that the Subversion filesystem is
<em>not</em> aware of "tags" or "branches."  It's only aware of
directories, and all directories are equal.  The tag and branch
concepts are purely <em>human</em> meanings attached to particular
directories.

<p>For this reason, it's up to users (and the Subversion repository
administrator) to choose sane policies that help elucidate these
labels.  For example, here's a good way to lay out your repository:

<br><pre>   /
   /projectA
   /projectA/trunk/
   /projectA/branches/
   /projectA/tags/
   /projectB
   /projectB/trunk/
   /projectB/branches/
   /projectB/tags/
</pre>

<p>Each time <code>/projectA/trunk</code> reaches a taggable state, make a copy
of the directory somewhere in <code>/projectA/tags/</code>, and set the copy
to read-only.  Use the same procedure to create a branch in
<code>/projectA/branches/</code>.

<p>An alternate way to lay out a repository:

<br><pre>   /
   /trunk
   /trunk/projectA
   /trunk/projectB
   /branches
   /branches/projectA
   /branches/projectB
   /tags
   /tags/projectA
   /tags/projectB
</pre>

<p>Or, of course, you could just place each project into a dedicated
repository.  It's up to you.  (See <a href="#FAQ">FAQ</a>.)

<h4>Switching to a branch with <code>svn switch</code></h4>

<p>The <code>svn switch</code> command allows you to "move" some or all of
your working copy to a branch or tag.  For example, suppose I have a
working copy of <code>mooIRC</code>, and I'd like to work on some subsystem
as it appears in a subdirectory of <code>mooIRC-beta</code>.  At the same
time, I want the rest my working copy to remain on the original
<code>mooIRC</code> branch.  To do this, I switch the appropriate subdir to
the new branch location:

<br><pre>$ svn switch http://foo.com/repos/mooIRC-beta/subsystems/renderer \
             mooIRC/subsystems/renderer

U  mooIRC/subsystems/renderer/foo.c
U  mooIRC/subsystems/renderer/bar.h
U  mooIRC/subsystems/renderer/baz.c
</pre>

<p>Now my working copy of the <code>renderer</code> subdirectory represents a
different location on the server.

<p>Really, <code>svn switch</code> is just a fancier version of <code>svn
update</code>.  Whereas <code>svn update</code> has the ability to move your
working copy through time (either by updating to the latest revision,
or by updating to a specific revision given with <code>-r</code>),
<code>svn switch</code> is able to move your working copy through time
<em>and</em> space.

<p>If your working copy contains a number of "switched" subtrees from
different repository locations, it continues to function as normal. 
When you update, you'll receive patches to each subtree as
appropriate.  When you commit, your local changes will still be
applied as a single, atomic change to the repository.

<h4>Moving changes with <code>svn merge</code></h4>

<p>Suppose a team of programmers working on the <code>mooIRC-beta</code> branch
have fixed a critical bug, and the team working on the original
<code>mooIRC</code> branch would like to apply that change as well.

<p>The <code>svn merge</code> command is the answer.  You can think of
<code>svn merge</code> as a special kind of <code>svn diff</code>; only
instead of displaying unified diffs to the screen, it <em>applies</em>
the differences to your working copy as if they were local changes.

<p>For example, suppose the bug fix happened in a commit to the
<code>mooIRC-beta</code> branch in revision 102.

<br><pre>$ svn diff -r 101:102 http://foo.com/repos/mooIRC-beta

[...]   # diffs sent to screen

$ svn merge -r 101:102 http://foo.com/repos/mooIRC-beta mooIRC
U   mooIRC/glorb.c
U   mooIRC/src/floo.h
</pre>

<p>While the output of <code>svn merge</code> looks similar to
<code>svn update</code> or <code>svn switch</code>, it is in fact only applying
temporary changes to the working files.  Once the differences are
applied as local changes, you can examine them as usual with
<code>svn diff</code>, <code>svn status</code>, or undo them with
<code>svn revert</code> as usual.  If the changes are acceptable, you can
commit them.

<h4>Rolling back a change with <code>svn merge</code></h4>

<p>Another common use for <code>svn merge</code> is for rolling back a change
that has been committed.  Say you commit some changes in revision 10, and
later decide that they were a mistake.  You can easily revert the tree to
the state it was in at revision 9 with an <code>svn merge</code> command.

<br><pre>$ svn commit -m "change some stuff"
Sending        bar.c
Sending        foo.c
Transmitting file data ..
Committed revision 10.
$

[...] # developer continues on and realizes he made a mistake

$ svn merge -r 10:9 .
U ./bar.c
U ./foo.c
$ svn commit -m "oops, reverting revision 10"
Sending        bar.c
Sending        foo.c
Transmitting file data ..
Committed revision 11.
</pre>

<p>If you aren't rolling back the changes to your current directory (say you
want to roll back one specific file, or all the files in one specific
subdirectory), then the syntax is slightly different, as you have to tell
<code>svn merge</code> where it should merge the changes into.

<br><pre>$ svn merge -r 10:9 baz/ baz/
U ./baz/bar.c
U ./baz/foo.c
$ svn commit -m "reverting revision 10's changes in baz/"
Sending        baz/bar.c
Sending        baz/foo.c
Transmitting file data ..
Committed revision 12.
$

[...] # developer continues on and later makes another mistake

$ svn merge -r 13:12 baz/foo.c baz/foo.c
U ./baz/foo.c
$ svn commit -m "reverting revision 12's change to foo.c"
Sending        baz/foo.c
Transmitting file data .
Committed revision 15.
</pre>

<p>Keep in mind that rolling back a change like this is just like any other
<code>svn merge</code> operation, so you should use <code>svn status</code> and
<code>svn diff</code> to confirm that your work is in the state you want it
to be in, and then use <code>svn commit</code> to send the final version to
the repository.

<h4>Vendor branches</h4>

<p>Sometimes you want to manage modified third-party source code inside your
Subversion repository, while still tracking upstream releases.  In CVS
this would have been called a "vendor branch".  Subversion doesn't have
a formal "vendor branch", but it is sufficiently flexible that you can
still do much the same thing.

<p>The general procedure goes like like this.  You create a top level
directory (we'll use <code>/vendor</code>) to hold the vendor branches.  Then you
import the third party code into a subdirectory of <code>/vendor</code>, and copy it
into <code>/trunk</code> where you make your local changes.  With each new
release of the code you are tracking you bring it into the vendor branch
and merge the changes into <code>/trunk</code>, resolving whatever conflicts occur
between your local changes and the upstream changes.

<p>Let's try and make this a bit clearer with an example.

<p>First, the initial import.

<br><pre>$ svn mkdir http://svnhost/repos/vendor/foobar
$ svn import http://svnhost/repos/vendor/foobar ~/foobar-1.0 current
</pre>

<p>Now we've got the current version of the foobar project in
<code>/vendor/foobar/current</code>.  We make another copy of it so we can
always refer to that version, and then copy it into the trunk so you can
work on it.

<br><pre>$ svn copy http://svnhost/repos/vendor/foobar/current    \
           http://svnhost/repos/vendor/foobar/foobar-1.0 \
           -m `tagging foobar-1.0'
$ svn copy http://svnhost/repos/vendor/foobar/foobar-1.0 \
           http://svnhost/repos/trunk/foobar             \
           -m `bringing foobar-1.0 into trunk'
</pre>

<p>Now you just check out a copy of <code>/trunk/foobar</code> and get to work!

<p>Later on, the developers at FooBar Widgets, Inc release a new version of
their code, so you want to update the version of the code you're using. 
First, you check out the <code>/vendor/foobar/current</code> directory, then
copy the new release over that working copy, handle any renames,
additions or removals manually, and then commit.

<br><pre>$ svn co http://svnhost/repos/vendor/foobar/current ~/current
$ cd ~/foobar-1.1
$ tar -cf - . | (cd ~/current ; tar -xf -)
$ cd ~/current
$ mv foobar.c main.c
$ svn mv main.c foobar.c
$ svn rm dead.c
$ svn add doc
$ svn add doc/*
$ svn commit -m `importing foobar 1.1 on vendor branch'
</pre>

<p>Whoa, that was complicated. Don't worry, most cases are far simpler.

<p>What happened? foobar 1.0 had a file called <code>main.c</code>.  This file
was renamed to <code>foobar.c</code> in 1.1.  So your working-copy had the old
<code>main.c</code> which <code>svn</code> knew about, and the new
<code>foobar.c</code> which <code>svn</code> did not know about.  You rename
<code>foobar.c</code> to <code>main.c</code> and <code>svn mv</code> it back to the new
name.  This way, <code>svn</code> will know that <code>foobar.c</code> is a
descendant of <code>main.c</code>.  <code>dead.c</code> has vanished in 1.1, and
they have finally written some documentation, so you add that.

<p>Next you copy <code>/vendor/foobar/current</code> to
<code>/vendor/foobar/foobar-1.1</code> so you can always refer back to version
1.1, like this.

<br><pre>$ svn copy http://svnhost/repos/vendor/foobar/current    \
           http://svnhost/repos/vendor/foobar/foobar-1.1 \
           -m `tagging foobar-1.1'
</pre>

<p>Now that you have a pristine copy of foobar 1.1 in <code>/vendor</code>, you
just have to merge their changes into <code>/trunk</code> and you're done. 
That looks like this.

<br><pre>$ svn co http://svnhost/repos/trunk/foobar ~/foobar
$ cd ~/foobar
$ svn merge http://svnhost/repos/vendor/foobar/foobar-1.0 \
            http://svnhost/repos/vendor/foobar/foobar-1.1
$
[...] # resolve all the conflicts between their changes and your changes
$ svn commit -m `merging foobar 1.1 into trunk'
</pre>

<p>There, you're done.  You now have a copy of foobar 1.1 with all your local
changes merged into it in your tree.

<p>Vendor branches that have more than several deletes, additions and moves
can use the <code>svn_load_dirs.pl</code> script that comes with the
Subversion distribution.  This script automates the above importing
steps to make sure that mistakes are minimized.  You still need to use
the merge commands to merge the new versions of foobar into your own
local copy containing your local modifications.

<p>This script takes care of complications where Subversion requires a
commit before renaming a file or directory twice, such as if you had a
vendor branch that renamed <code>foobar-1.1/docs/doc.ps</code> to
<code>foobar-1.2/documents/doc-1.2.ps</code>.  Here, you would rename
<code>docs</code> to <code>documents</code>, perform a commit, then rename
<code>doc.ps</code> to <code>doc-1.2.ps</code>.  You could not do the two renames
without the commit, because <code>doc.ps</code> was already moved once from
<code>docs/doc.ps</code> to <code>documents/doc.ps</code>.

<p>This script always compares the directory being imported to what
currently exists in the Subversion repository and takes the necessary
steps to add, delete and rename files and directories to make the
subversion repository match the imported directory.  As such, it can be
used on an empty subversion directory for the first import or for any
following imports to upgrade a vendor branch.

<p>For the first foobar-1.0 release located in <code>~/foobar-1.0</code>:

<br><pre>$ svn_load_dirs.pl -t foobar-1.0                      \
                   http://svnhost/repos/vendor/foobar \
                   current                            \
                   ~/foobar-1.0
</pre>

<p><code>svn_load_dirs.pl</code> takes three mandatory arguments.  The first
argument, &lt;<code>http://svnhost/repos/vendor/foobar</code>&gt;, is the URL to the
base Subversion directory to work in.  In this case, we're working in
the <code>vendor/foobar</code> part of the Subversion repository.  The next argument,
<code>current</code>, is relative to the first and is the directory where the
current import will take place, in this case
&lt;<code>http://svnhost/repos/vendor/foobar/current</code>&gt;.  The last argument,
<code>~/foobar-1.0</code>, is the directory to import.  Finally, the optional
<code>-t</code> command line option is also relative to
&lt;<code>http://svnhost/repos/vendor/foobar</code>&gt; and tells
<code>svn_load_dirs.pl</code> to create a tag of the imported directory in
&lt;<code>http://svnhost/repos/vendor/foobar/foobar-1.0</code>&gt;.

<p>The import of foobar-1.1 would be taken care of in the same way:

<br><pre>$ svn_load_dirs.pl -t foobar-1.1                      \
                   http://svnhost/repos/vendor/foobar \
                   current                            \
                   ~/foobar-1.1
</pre>

<p>The script looks in your current
&lt;<code>http://svnhost/repos/vendor/foobar/current</code>&gt; directory and sees
what changes need to take place for it to match <code>~/foobar-1.1</code>. 
The script is kind enough to notice that there are files and directories
that exist in 1.0 and not in 1.1 and asks if you want to perform any
renames.  At this point, you can indicate that <code>main.c</code> was renamed to
<code>foobar.c</code> and then indicate that no further renames have taken place.

<p>The script will then delete <code>dead.c</code> and add <code>doc</code> and
<code>doc/*</code> to the Subversion repository and finally create a tag
foobar-1.1 in &lt;<code>http://svnhost/repos/vendor/foobar/foobar-1.1</code>&gt;.

<h4>Removing a branch or tag with <code>svn rm</code></h4>

<p>The <code>svn rm</code> command can operate on URLs.  A file or directory
can be "remotely" deleted from the repository, with no working copy
present:

<br><pre>$ svn rm http://foo.com/repos/tags/mooIRC-bad-tag -m "deleting bad tag"
Committed revision 1023.
</pre>

<p>Of course, this is still a form of immediate commit, so some kind of
log message is still required.

<p>Enough said!

<p><hr>
Node:<a name="Properties">Properties</a>,
Next:<a rel=next href="#Modules">Modules</a>,
Previous:<a rel=previous href="#Branches%20and%20Tags">Branches and Tags</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>Properties</h3>

<p>Subversion allows you to attach arbitrary "metadata" to files and
directories.  We refer to this data as <dfn>properties</dfn>, and they can
be thought of as collections of name/value pairs (hash-tables) attached
to each item in your working copy.

<p>To set or get a property on a file or directory, use the <code>svn
propset</code> and <code>svn propget</code> commands.  To list all properties
attached to an item, use <code>svn proplist</code>.  To delete a
property, use <code>svn propdel</code>.

<br><pre>$ svn propset color green foo.c
property `color' set on 'foo.c'

$ svn propget color foo.c
green

$ svn propset height "5 feet" foo.c
property `height' set on 'foo.c'

$ svn proplist foo.c
Properties on 'foo.c':
  height
  color

$ svn proplist foo.c --verbose
Properties on 'foo.c':
  height : 5 feet
  color : green

$ svn propdel color foo.c
property `color' deleted from 'foo.c'
</pre>

<p>Properties are <em>versioned</em>, just like file contents.  This means
that new properties can be merged into your working files, and can
sometimes come into conflict too.  Property values need not be text,
either.  For example, you could attach a binary property-value by
using the <code>-F</code> switch:

<br><pre>$ svn propset x-face -F joeface.jpg foo.c
property `x-face' set on 'foo.c'
</pre>

<p>Subversion also provides a great convenience method for editing
existing properties: <code>svn propedit</code>. When you invoke it,
Subversion will open the value of the property in question in your
favorite editor (or at least the editor that you've defined as <code>$EDITOR</code>
in your shell), and you can edit the value just as you would edit any
text file. This is exceptionally convenient for properties that are a
newline-separated array of values. (See below.)

<p>Property changes are still considered "local modifications", and
aren't permanent until you commit.  Like textual changes, property
changes can be seen by <code>svn diff</code>, <code>svn status</code>, and
reverted altogether with <code>svn revert</code>:

<br><pre>$ svn diff
Property changes on: foo.c
___________________________________________________________________
Name: color
   + green

$ svn status
_M   foo.c
</pre>

<p>Notice that a 2nd column has appeared in the status output; the
leading underscore indicates that you've not made any textual changes,
but the <code>M</code> means you've modified the properties.  <code>svn
status</code> tries to hide the 2nd "property" column when an item has no
properties at all; this was a design choice, to ease new users into
the concept.  When properties are created, edited, or updated on an
item, that 2nd column appears forever after.

<p>Also: don't worry about the non-standard way that Subversion currently
displays property differences.  You can still run <code>svn diff</code>
and redirect the output to create a usable patch file.  The
<code>patch</code> program will ignore property patches; as a rule, it
ignores any noise it can't understand.  (In future versions of
Subversion, though, we may start using a new patch format that
describes property changes and file copies/renames.)

<h4>Special properties</h4>

<p>Subversion has no particular policy regarding properties; they can be
used for any purpose.  The only restriction is that Subversion has
reserved the <code>svn:</code> name prefix for itself.  A number of special
"magic" properties begin with this prefix.  We'll cover these
features here.

<h5><code>svn:executable</code></h5>

<p>This is a file-only property, and can be set to any value.  Its mere
existence causes a file's permissions to be executable.

<h5><code>svn:mime-type</code></h5>

<p>At the present time, Subversion examines the <code>svn:mime-type</code> property
to decide if a file is text or binary.  If the file has no
<code>svn:mime-type</code> property, or if the property's value matches
<code>text/*</code>, then Subversion assumes it is a text file.  If the file
has the <code>svn:mime-type</code> property set to anything other than
<code>text/*</code>, it assumes the file is binary.

<p>If Subversion believes that the file is binary, it will not attempt to
perform contextual merges during updates.  Instead, Subversion creates
two files side-by-side in your working copy; the one containing your
local modifications is renamed with an <code>.orig</code> extension.

<p>Subversion also helps users by running a binary-detection algorithm in
the <code>svn import</code> and <code>svn add</code> subcommands.  These subcommands try to
make a good guess at a file's binary-ness, and then (possibly) set a
<code>svn:mime-type</code> property of <code>application/octet-stream</code> on the file
being added.  (If Subversion guesses wrong, you can always remove or
hand-edit the property.)

<p>Finally, if the <code>svn:mime-type</code> property is set, then mod_dav_svn will
use it to fill in the <code>Content-type:</code> header when responding to an
http GET request.  This makes files display more nicely when perusing
a repository with a web browser.

<h5><code>svn:ignore</code></h5>

<p>If you attach this property to a directory, it causes certain file
patterns within the directory to be ignored by <code>svn status</code>. 
For example, suppose I don't want to see object files or backup files
in my status listing:

<br><pre>$ svn status
M  ./foo.c
?  ./foo.o
?  ./foo.c~
</pre>

<p>Using <code>svn propedit</code>, I would set the value of
<code>svn:ignore</code> to a newline-delimited list of patterns:

<br><pre>$ svn propget svn:ignore .
*.o
*~
</pre>

<h5><code>svn:keywords</code></h5>

<p>Subversion has the ability to substitute useful strings into special
"keywords" within text files.  For example, if I placed this text
into a file:

<br><pre>Here is the latest report from the front lines.
$LastChangedDate$
Cumulus clouds are appearing more frequently as summer approaches.
</pre>

<p>Subversion is able substitute the <code>$LastChangedDate$</code> string with
the actual date in which this file last changed.  The keyword string is
not removed in the replacement, just the specific information is placed
after the keyword string:

<br><pre>Here is the latest report from the front lines.
$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $
Cumulus clouds are appearing more frequently as summer approaches.
</pre>

<p>All in all, there are four special keywords that Subversion knows how
to substitute:

<dl>
<dt><b>LastChangedDate</b>
<dd>The last time this file changed.  Can also be abbreviated as <code>Date</code>. 
The keyword substitution of <code>$LastChangedDate$</code> will look something
like
<code>$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $</code>.

<br><dt><b>LastChangedRevision</b>
<dd>The last revision in which this file changed.  Can be abbreviated as
<code>Rev</code>.  The keyword substitution of <code>$LastChangedRevision</code> will
look something like <code>$LastChangedRevision: 144 $</code>.

<br><dt><b>LastChangedBy</b>
<dd>The last user to change this file.  Can be abbreviated as <code>Author</code>.  The
keyword substitution of <code>$LastChangedBy$</code> will look something like
<code>$LastChangedBy: joe $</code>.

<br><dt><b>HeadURL</b>
<dd>A full URL to the latest version of the file in the repository.  Can be
abbreviated as <code>URL</code>.  The keyword substitution of <code>$HeadURL$</code> will
look something like
<code>$HeadURL: http://svn.collab.net/repos/trunk/README $</code>. 
</dl>

<p>To activate a keyword, or set of keywords, you merely need to set the
<code>svn:keywords</code> property to a list of keywords you want replaced. 
Keywords not listed in <code>svn:keywords</code> will not be replaced.

<br><pre>$ svn propset svn:keywords "Date Author" foo.c
property `svn:keywords' set on 'foo.c'
</pre>

<p>And when you commit this property change, you'll discover that all
occurrences of <code>$Date$</code>, <code>$LastChangedDate$</code>,
<code>$Author$</code>, and <code>$LastChangedBy$</code> will have substituted
values within <code>foo.c</code>.

<h5><code>svn:eol-style</code></h5>

<p>By default, Subversion doesn't pay any attention to line endings.  If
a text file has either LF, CR, or CRLF endings, then those are the
line endings that will exist on the file in both the repository and
working copy.

<p>But if developers are working on different platforms, line endings can
sometimes become troublesome.  For example, if a Win32 developer and
Unix developer took turns modifying a file, its line endings might
flip-flop back and forth from revision to revision in the repository. 
This makes examining or merging differences very difficult, as
<em>every</em> line appears to be changed in each version of the file.

<p>The solution here is to set the <code>svn:eol-style</code> property to
"native".  This makes the file always appear with the "native"
line endings of each developer's operating system.  Note, however,
that the file will always contain LF endings in the repository.  This
prevents the line-ending "churn" from revision to revision.

<p>Alternately, you can force files to always retain a fixed, specific
line ending: set a file's <code>svn:eol-style</code> property to one of
<code>LF</code>, <code>CR</code> or <code>CRLF</code>.  A Win32 <code>.dsp</code> file, for
example, which is used by Microsoft development tools, should always
have CRLF endings.

<h5><code>svn:externals</code></h5>

<p>See <a href="#Modules">Modules</a>.

<p><hr>
Node:<a name="Modules">Modules</a>,
Next:<a rel=next href="#Revisions">Revisions</a>,
Previous:<a rel=previous href="#Properties">Properties</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>Modules</h3>

<p>Sometimes it's useful to construct a working copy that is made out of
a number of different checkouts.  For example, you may want different
sub-directories to come from different locations in a repository.

<p>On the one hand, you could begin by checking out a working copy, and
then run <code>svn switch</code> on various subdirectories.  But this is
a bit of work.  Wouldn't it be nice to define - in a single place -
exactly how you want the final working copy to be?

<p>This is known as a <dfn>module</dfn>.  You can define a module by attaching
another special "magic" <code>svn:</code> property to a directory: the
<code>svn:externals</code> property.

<p>The value of this property is a list of subdirectories and
their corresponding URLs:

<br><pre>$ svn propget svn:externals projectdir
subdir1/foo       http://url.for.external.source/foo
subdir1/bar       http://blah.blah.blah/repositories/theirproj
subdir1/bar/baz   http://blorg.blorg.blorg/basement/code
</pre>

<p>Assuming that this property is attached to the directory
<code>projectdir</code>, then when we check it out, we'll get everything
else defined by the property.

<br><pre>$ svn checkout http://foo.com/repos/projectdir
A  projectdir/blah.c
A  projectdir/gloo.c
A  projectdir/trout.h
Checked out revision 128.

Fetching external item into projectdir/subdir1/foo
A  projectdir/subdir1/foo/rho.txt
A  projectdir/subdir1/foo/pi.txt
A  projectdir/subdir1/foo/tau.doc
Checked out revision 128.
[...]
</pre>

<p>By tweaking the value of the <code>svn:externals</code> property, the
definition of the module can change over time, and subsequent calls to
<code>svn update</code> will update working copies appropriately.

<p><hr>
Node:<a name="Revisions">Revisions</a>,
Next:<a rel=next href="#Other%20Commands">Other Commands</a>,
Previous:<a rel=previous href="#Modules">Modules</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>Revisions</h3>

<p>As you may have noticed, many Subversion commands are able to process
the <code>-r</code> switch.  Here we describe some special ways to specify
revisions.

<p>The Subversion client understands a number of <dfn>revision keywords</dfn>. 
These keywords can be used instead of integer arguments to the
<code>-r</code> switch, and are resolved into specific revision numbers:

<dl>
<dt><b>HEAD</b>
<dd>The latest revision in the repository. 
<br><dt><b>BASE</b>
<dd>The "pristine" revision of an item in a working copy. 
<br><dt><b>COMMITTED</b>
<dd>The last revision in which an item changed. 
<br><dt><b>PREV</b>
<dd>The revision just <em>before</em> the last revision in which an item
changed.  (Technically, COMMITTED - 1). 
</dl>

<p>Here are some examples of revision keywords in action:

<br><pre>$ svn diff -r PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log -r HEAD
# shows log message for the latest repository commit

$ svn diff -r HEAD
# compares your working file (with local mods) to the latest version
# in the repository.

$ svn diff -r BASE:HEAD foo.c
# compares your "pristine" foo.c (no local mods) with the latest version
# in the repository

$ svn log -r BASE:HEAD
# shows all commit logs since you last updated

$ svn update -r PREV foo.c
# rewinds the last change on foo.c.
# (foo.c's working revision is decreased.)
</pre>

<p><hr>
Node:<a name="Other%20Commands">Other Commands</a>,
Next:<a rel=next href="#Run-time%20Configuration">Run-time Configuration</a>,
Previous:<a rel=previous href="#Revisions">Revisions</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>Other Commands</h3>

<h4><code>svn cleanup</code></h4>

<p>When Subversion modifies your working copy (or any information within
<code>.svn</code>), it tries to do so as safely as possible.  Before
changing anything, it writes its intentions to a logfile, then
executes the commands in the logfile.  It's similar in design to a
journaled filesystem; if the user hits Control-C or if the machine
crashes, the logfiles are left lying around.  By re-executing the
logfiles, the work can complete, and your working copy can get itself
back into a consistent state.

<p>And this is exactly what <code>svn cleanup</code> does: it searches your
working copy and re-runs any leftover logs, removing locks in the
process.  Use this command if Subversion ever tells you that some part
of your working copy is "locked".  Also, <code>svn status</code> will
display an <code>L</code> next to locked items:

<br><pre>$ svn st
  L    ./somedir
M      ./somedir/foo.c

$ svn cleanup
$ svn st
M      ./somedir/foo.c
</pre>

<h4><code>svn info</code></h4>

<p>In general, we try to discourage users from directly reading the
<code>.svn/entries</code> file used to track items.  Instead, curiosity can
be quelled by using the <code>svn info</code> to display most of the
tracked information:

<br><pre>$ svn info client.texi
Path: client.texi
Name: client.texi
Url: http://svn.collab.net/repos/svn/trunk/doc/handbook/client.texi
Revision: 2548
Node Kind: file
Schedule: normal
Last Changed Author: fitz
Last Changed Rev: 2545
Last Changed Date: 2002-07-15 23:03:54 -0500 (Mon, 15 Jul 2002)
Text Last Updated: 2002-07-16 08:48:04 -0500 (Tue, 16 Jul 2002)
Properties Last Updated: 2002-07-16 08:48:03 -0500 (Tue, 16 Jul 2002)
Checksum: 8sfaU+5dqyOgkhuSdyxGrQ==
</pre>

<h4><code>svn import</code></h4>

<p>The import command is a quick way to move an unversioned tree of files
into a repository.

<p>There are two ways to use this command:

<br><pre>$ svnadmin create /usr/local/svn/newrepos
$ svn import file:///usr/local/svn/newrepos mytree
Adding  mytree/foo.c
Adding  mytree/bar.c
Adding  mytree/subdir
Adding  mytree/subdir/quux.h
Transmitting file data....
Committed revision 1.
</pre>

<p>The above example places the contents of directory <code>mytree</code>
directly into the root of the repository:

<br><pre>/foo.c
/bar.c
/subdir
/subdir/quux.h
</pre>

<p>If you give <code>svn import</code> a third argument, it will use the
argument as the name of a new subdirectory to create within the URL.

<br><pre>$ svnadmin create /usr/local/svn/newrepos
$ svn import file:///usr/local/svn/newrepos mytree fooproject
Adding  mytree/foo.c
Adding  mytree/bar.c
Adding  mytree/subdir
Adding  mytree/subdir/quux.h
Transmitting file data....
Committed revision 1.
</pre>

<p>The repository would now look like

<br><pre>/fooproject/foo.c
/fooproject/bar.c
/fooproject/subdir
/fooproject/subdir/quux.h
</pre>

<h4><code>svn export</code></h4>

<p>The export command is a quick way to create an unversioned tree of
files from a repository directory.

<br><pre>$ svn export file:///usr/local/svn/newrepos/fooproject
A  fooproject/foo.c
A  fooproject/bar.c
A  fooproject/subdir
A  fooproject/subdir/quux.h
Checked out revision 3.
</pre>

<p>The resulting directory will not contain any <code>.svn</code>
administrative areas, and all property metadata will be lost.  (Hint:
don't use this tecnique for backing up; it's probably better for
rolling source distributions.)

<h4><code>svn mkdir</code></h4>

<p>This is another convenience command, and it has two uses.

<p>First, it can be used to simultaneously create a new working copy
directory and schedule it for addition:

<br><pre>$ svn mkdir new-dir
A     new-dir
</pre>

<p>Or, it can be used to instantly create a directory in a repository (no
working copy needed):

<br><pre>$ svn mkdir file:///usr/local/svn/newrepos/branches -m "made new dir"
Committed revision 1123.
</pre>

<p>Again, this is a form of immediate commit, so some sort of log message
is required.

<p><hr>
Node:<a name="Run-time%20Configuration">Run-time Configuration</a>,
Previous:<a rel=previous href="#Other%20Commands">Other Commands</a>,
Up:<a rel=up href="#Client%20Cookbook">Client Cookbook</a>
<br>

<h3>Run-time Configuration</h3>

<p>When you first run the <code>svn</code> command-line client, it creates a
per-user <dfn>configuration area</dfn>.  On Unix-like systems, a
<code>.subversion/</code> directory is created in the user's home
directory.  On Win32 systems, a <code>Subversion</code> folder is created
wherever it's appropriate to do so (typically somewhere within
<code>Documents and Settings\username</code>, although it depends on the
system.)

<h4>Proxies</h4>

<p>At the time of writing, the configuration area only contains one item:
a <code>proxies</code> file.  By setting values in this this file, your
Subversion client can operate through an http proxy.  (Read the file
itself for details; it should be self-documenting.)

<h4>Config</h4>

<p>Soon - very soon - a <code>config</code> file will exist in this area for
defining general user preferences.  For example, the preferred
<code>$EDITOR</code> to use, options to pass through to <code>svn diff</code>,
preferences for date/time formats, and so on.  See issue #668 for
details
(<a href="http://subversion.tigris.org/issues/show_bug.cgi?id=668">http://subversion.tigris.org/issues/show_bug.cgi?id=668</a>).

<h4>Multiple config areas</h4>

<p>On Unix, an administrator can create"global" Subversion preferences
by creating and populating an <code>/etc/subversion/</code> area.  The
per-user <code>~/.subversion/</code> configuration will still override these
defaults, however.

<p>On Win32, an administrator has the option of creating three other
locations: a global <code>Subversion</code> folder in the "All Users"
area, a collection of global registry settings, or a collection of
per-user registry settings.  The registry settings are set in:

<br><pre>HKCU\Software\Tigris.org\Subversion\Proxies
HKCU\Software\Tigris.org\Subversion\Config
etc.
</pre>

<p>To clarify, here is the order Subversion searches for run-time
settings on Win32.  Each subsequent location overrides the previous
one:

<ul>
<li>global registry
<li>global <code>Subversion</code> folder
<li>user registry
<li>user <code>Subversion</code> folder
</ul>

<p><hr>
Node:<a name="Repository%20Administration">Repository Administration</a>,
Next:<a rel=next href="#Appendices">Appendices</a>,
Previous:<a rel=previous href="#Client%20Cookbook">Client Cookbook</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h2>Repository Administration</h2>

<p>How to administer a Subversion repository.

<p>In this section, we'll mainly focus on how to use the
<code>svnadmin</code> and <code>svnlook</code> programs to work with repositories.

<ul>
<li><a href="#Creating%20a%20repository">Creating a repository</a>: 
<li><a href="#Examining%20a%20repository">Examining a repository</a>: 
<li><a href="#Repository%20hooks">Repository hooks</a>: 
<li><a href="#Repository%20maintenance">Repository maintenance</a>: 
<li><a href="#Networking%20a%20repository">Networking a repository</a>: 
<li><a href="#Migrating%20a%20repository">Migrating a repository</a>: 
<li><a href="#WebDAV">WebDAV</a>: 
</ul>

<p><hr>
Node:<a name="Creating%20a%20repository">Creating a repository</a>,
Next:<a rel=next href="#Examining%20a%20repository">Examining a repository</a>,
Up:<a rel=up href="#Repository%20Administration">Repository Administration</a>
<br>

<h3>Creating a repository</h3>

<p>Creating a repository is incredibly simple:

<br><pre>$ svnadmin create path/to/myrepos
</pre>

<p>This creates a new repository in a subdirectory <code>myrepos</code>.

<p>(Note that the <code>svnadmin</code> and <code>svnlook</code> programs
operate <em>directly</em> on a repository, by linking to <code>libsvn_fs.so</code>. 
So these tools expect ordinary, local paths to the repositories.  This
is in contrast with the <code>svn</code> client program, which always
accesses a repository via some URL, whether it be via &lt;<code>http://</code>&gt;
or &lt;<code>file:///</code>&gt; schemas.)

<p>A new repository always begins life at revision 0, which is defined to
be nothing but the root (<code>/</code>) directory.

<p>As mentioned earlier, repository revisions can have unversioned
properties attached to them.  In particular, every revision is created
with a <code>svn:date</code> timestamp property.  (Other common properties
include <code>svn:author</code> and <code>svn:log</code>)

<p>For a newly created repository, revision 0 has nothing but a
<code>svn:date</code> property attached.

<p>Here is a quick run-down of the anatomy of a repository:

<br><pre>$ ls myrepos
conf/
dav/
db/
hooks/
locks/
</pre>

<dl>
<dt><code>conf</code>
<dd>Currently unused; repository-side config files will go in here someday. 
<br><dt><code>dav</code>
<dd>If the repository is being accessed by Apache and mod_dav_svn, some
private housekeeping databases are stored here. 
<br><dt><code>db</code>
<dd>The main Berkeley DB environment, full of DB tables that comprise the
data store for libsvn_fs.  This is where all of your data is!  In
particular, most of your files' contents end up in the "strings" table. 
Logfiles accumulate here as well, so transactions can be recovered. 
<br><dt><code>hooks</code>
<dd>Where pre-commit and post-commit hook scripts live.  (And someday, read-hooks.) 
<br><dt><code>locks</code>
<dd>A single file lives here; repository readers and writers take out
shared locks on this file.  Do not remove this file. 
</dl>

<p>Once the repository has been created, it's very likely that you'll
want to use the svn client to import an initial tree.  (Try
<code>svn help import</code>, or See <a href="#Other%20Commands">Other Commands</a>.)

<p><hr>
Node:<a name="Examining%20a%20repository">Examining a repository</a>,
Next:<a rel=next href="#Repository%20hooks">Repository hooks</a>,
Previous:<a rel=previous href="#Creating%20a%20repository">Creating a repository</a>,
Up:<a rel=up href="#Repository%20Administration">Repository Administration</a>
<br>

<h3>Examining a repository</h3>

<h4>Transactions and Revisions</h4>

<p>A Subversion repository is essentially a sequence of trees; each tree
is called a <dfn>revision</dfn>.  (If this is news to you, it might be good
for you to read <a href="#Transactions%20and%20Revision%20Numbers">Transactions and Revision Numbers</a>.)

<p>Every revision begins life as a <dfn>transaction</dfn> tree.  When doing a
commit, a client builds a transaction that mirrors their local changes,
and when the commit succeeds, the transaction is effectively "promoted"
into a new revision tree, and is assigned a new revision number.

<p>At the moment, updates work in a similar way: the client builds a
transaction tree that is a "mirror" of their working copy.  The
repository then compares the transaction tree with some revision tree,
and sends back a tree-delta.  After the update completes, the
transaction is deleted.

<p>Transaction trees are the only way to "write" to the repository's
versioned filesystem; all users of libsvn_fs will do this.  However,
it's important to understand that the lifetime of a transaction is
completely flexible.  In the case of updates, transactions are temporary
trees that are immediately destroyed.  In the case of commits,
transactions are transformed into permanent revisions (or aborted if the
commit fails.)  In the case of an error or bug, it's possible that a
transaction can be accidentally left lying around - the libsvn_fs
caller might die before deleting it.  And in theory, someday whole
workflow applications might revolve around the creation of transactions;
they might be examined in turn by different managers before being
deleted or promoted to revisions.

<p>The point is: if you're administering a Subversion repository, you're
going to have to examine revisions and transactions.  It's part of
monitoring the health of the repository.

<h4><code>svnlook</code></h4>

<p><code>svnlook</code> is a read-only<a rel=footnote href="#fn-2"><sup>2</sup></a> tool that can be
used to examine the revision and transaction trees within a repository. 
It's useful for system administrators, and can be used by the
<code>pre-commit</code> and <code>post-commit</code> hook scripts as well.

<p>The simplest usage is

<br><pre>$ svnlook repos
</pre>

<p>This will print information about the HEAD revision in the repository
"repos."  In particular, it will show the log message, author, date, and
a diagram of the tree.

<p>To look at a particular revision or transaction:

<br><pre>$ svnlook repos rev 522
$ svnlook repos txn 340
</pre>

<p>Or, if you only want to see certain types of information,
<code>svnlook</code> accepts a number of subcommands.  For example,

<br><pre>$ svnlook repos rev 522 log
$ svnlook repos rev 559 diff
</pre>

<p>Available subcommands are:

<dl>
<dt><code><code>log</code></code>
<dd>Print the tree's log message. 
<br><dt><code><code>author</code></code>
<dd>Print the tree's author. 
<br><dt><code><code>date</code></code>
<dd>Print the tree's datestamp. 
<br><dt><code><code>dirs-changed</code></code>
<dd>List the directories that changed in the tree. 
<br><dt><code><code>changed</code></code>
<dd>List all files and directories that changed in the tree. 
<br><dt><code><code>diff</code></code>
<dd>Print unified diffs of changed files. 
</dl>

<h4>the shell</h4>

<p>The <code>svnadmin</code> tool has a toy "shell" mode as well.  It doesn't
do much, but it allows you to poke around the repository as if it were
an imaginary mounted filesystem.  The basic commands <code>cd</code>,
<code>ls</code>, <code>exit</code>, and <code>help</code> are available, as well
as the very special command <code>cr</code> - "change revision."  The last
command allows you to move <em>between</em> revision trees.

<br><pre>$ svnadmin shell repos
&lt;609: /&gt;$
&lt;609: /&gt;$ ls
  &lt; 1.0.2i7&gt;  [   601]  1           0    trunk/
  &lt;nh.0.2i9&gt;  [   588]  0           0    branches/
  &lt;jz.0.18c&gt;  [   596]  0           0    tags/

&lt;609: /&gt;$ cd trunk
&lt;609: /trunk&gt;$ cr 500
&lt;500: /trunk&gt;$ ls
  &lt;   2.0.1&gt;  [     1]  0        3462    svn_config.dsp
  &lt;  4.0.dj&gt;  [   487]  0        3856    PORTING
  &lt;  3.0.cr&gt;  [   459]  0        7886    Makefile.in
  &lt;  d.0.ds&gt;  [   496]  0        9736    build.conf
  &lt;  5.0.d9&gt;  [   477]  1           0    ac-helpers/
  &lt;   y.0.1&gt;  [     1]  0        1805    subversion.dsp
[...]
&lt;500: /&gt;$ exit
</pre>

<p>The output of <code>ls</code> has only a few columns:

<br><pre>  NODE-ID  CREATED-REV HAS_PROPS?  SIZE  NAME

  &lt; 1.0.2i7&gt;  [   601]  1           0    trunk/
  &lt;nh.0.2i9&gt;  [   588]  0           0    branches/
  &lt;jz.0.18c&gt;  [   596]  0           0    tags/
</pre>

<p><hr>
Node:<a name="Repository%20hooks">Repository hooks</a>,
Next:<a rel=next href="#Repository%20maintenance">Repository maintenance</a>,
Previous:<a rel=previous href="#Examining%20a%20repository">Examining a repository</a>,
Up:<a rel=up href="#Repository%20Administration">Repository Administration</a>
<br>

<h3>Repository hooks</h3>

<p>A <dfn>hook</dfn> is a program triggered by a repository read or write
access.  The hook is handed enough information to tell what the action
is, what target(s) it's operating on, and who is doing it.  Depending on
the hook's output or return status, the hook program may continue the
action, stop it, or suspend it in some way.

<p>Subversion's hooks are programs that live in the repository's <code>hooks</code>
directory:

<br><pre>$ ls repos/hooks/
post-commit.tmpl*  read-sentinels.tmpl  write-sentinels.tmpl
pre-commit.tmpl*   start-commit.tmpl*
</pre>

<p>This is how the <code>hooks</code> directory appears after a repository is first
created.  It doesn't contain any hook programs - just templates.

<p>The actual hooks need to be named <code>start-commit</code>, <code>pre-commit</code> and
<code>post-commit</code>.  The template (.tmpl) files are example shell scripts to
get you started; read them for details about how each hook works.  To
make your own hook, just copy <code>foo.tmpl</code> to <code>foo</code> and edit.

<p>(The <code>read-sentinels</code> and <code>write-sentinels</code> are not yet implemented. 
They are intended to be more like daemons than hooks.  A sentinel is
started up at the beginning of a user operation.  The Subversion
server communicates with the sentinel using a protocol yet to be
defined.  Depending on the sentinel's responses, Subversion may stop
or otherwise modify the operation.)

<p>Here is a description of the hook programs:

<dl>

<br><dt><code><code>start-commit</code></code>
<dd>This is run before the committer's transaction is even created.  It is
typically used to decide if the user has commit privileges at all.  The
repository passes two arguments to this program: the path to the
repository, and username which is attempting to commit.  If the program
returns a non-zero exit value, the commit is stopped before the
transaction is even created.

<br><dt><code><code>pre-commit</code></code>
<dd>This is run when the transaction is complete, but before it is
committed.  Typically, this hook is used to protect against commits that
are disallowed due to content or location (for example, your site might
require that all commits to a certain branch include a ticket number
from the bug tracker, or that the incoming log message is
non-empty.)<a rel=footnote href="#fn-3"><sup>3</sup></a>  The repository passes two
arguments to this program: the path to the repository, and the name of
the transaction being committed.  If the program returns a non-zero exit
value, the commit is aborted and transaction is removed.

<p>The Subversion distribution includes a
<code>tools/hook-scripts/commit-access-control.pl</code> script that can be
called from <code>pre-commit</code> to implement fine-grained access control.

<br><dt><code>post-commit</code>
<dd>This is run after the transaction is committed, and we have a new
revision.  Most people use this hook to send out descriptive
commit-emails or to make a hot-backup of the repository.  The repository
passes two arguments to this program: the path to the repository, and
the new revision number that was created.  The exit code of the program
is ignored.

<p>The Subversion distribution includes a
<code>tools/hook-scripts/commit-email.pl</code> script that can be used to
send out the differences applied in the commit to any number of email
addresses.  Also included is <code>tools/backup/hot-backup.py</code>, which is
a script that perform hot backups of your Subversion repository after
every commit.

</dl>

<p>Note that the hooks must be executable by the user who will invoke them
(commonly the user httpd runs as), and that that same user needs to be
able to access the repository.

<p>The <code>pre-commit</code> and <code>post-commit</code> hooks need to know things
about the change about to be committed (or that has just been
committed).  The solution is a standalone program, <code>svnlook</code>
(See <a href="#Examining%20a%20repository">Examining a repository</a>.) which was installed in the same place
as the <code>svn</code> binary.  Have the script use <code>svnlook</code> to
examine a transaction or revision tree.  It produces output that is both
human- and machine-readable, so hook scripts can easily parse it.  Note
that <code>svnlook</code> is read-only - it can only inspect, not change
the repository.

<p><hr>
Node:<a name="Repository%20maintenance">Repository maintenance</a>,
Next:<a rel=next href="#Networking%20a%20repository">Networking a repository</a>,
Previous:<a rel=previous href="#Repository%20hooks">Repository hooks</a>,
Up:<a rel=up href="#Repository%20Administration">Repository Administration</a>
<br>

<h3>Repository maintenance</h3>

<h4>Berkeley DB management</h4>

<p>At the time of writing, the subversion repository has only one
database back-end: Berkeley DB.  All of your filesystem's structure
and data live in a set of tables within <code>repos/db/</code>.

<p>Berkeley DB comes with a number of tools for managing these files, and
they have their own excellent documentation.  (See
<a href="http://www.sleepycat.com/">http://www.sleepycat.com/</a>, or just read man pages.)  We won't
cover all of these tools here; rather, we'll mention just a few of the
more common procedures that repository administrators might need.

<p>First, remember that Berkeley DB has genuine transactions.  Every
attempt to change the DB is first logged.  If anything ever goes
wrong, the DB can back itself up to a previous `checkpoint' and
replay transactions to get the data back into a sane state.

<p>In our experience, we have seen situations where a bug in Subversion
(which causes a crash) can sometimes have a side-effect of leaving the
DB environment in a `locked' state.  Any further attempts to read or
write to the repository just sit there, waiting on the lock.

<p>To `unwedge' the repository, use <code>db_recover</code>:

<br><pre>$ db_recover -ve -h repos/db
db_recover: Finding last valid log LSN: file: 40 offset 4080873
db_recover: Checkpoint at: [40][4080333]
db_recover: Checkpoint LSN: [40][4080333]
db_recover: Previous checkpoint: [40][4079793]
db_recover: Checkpoint at: [40][4079793]
db_recover: Checkpoint LSN: [40][4079793]
db_recover: Previous checkpoint: [40][4078761]
db_recover: Recovery complete at Sun Jul 14 07:15:42 2002
db_recover: Maximum transaction id 80000000 Recovery checkpoint [40][4080333]
</pre>

<p>Make sure you run this command as the user that owns and manages the
database and <em>not</em> as root.  Running <code>db_recover</code> as root
will leave root owned files in the db directory which cannot be opened
by the non-root user that manages the database, which is typically
your Apache process.

<p>Second, a repository administrator may need to manage the growth of
logfiles.  At any given time, the DB environment is using at least one
logfile to log transactions; when the `current' logfile grows to 10
megabytes, a new logfile is started, and the old one continues to
exist.

<p>Thus, after a while, you may see a whole group of 10MB logfiles lying
around the environment.  At this point, you can make a choice: if you
leave every single logfile behind, it's guaranteed that
<code>db_recover</code> will always be able to replay every single DB
transaction, all the way back to the first commit.  (This is the
`safe', or perhaps paranoid, route.)  On the other hand, you can ask
Berkeley DB to tell you which logfiles are no longer being actively
written to:

<br><pre>$ db_archive -a -h repos/db
log.0000000023
log.0000000024
log.0000000029
</pre>

<p>Subversion's own repository uses a <code>post-commit</code> hook script, which,
after performing a `hot-backup' of the repository, removes these
excess logfiles.  (In the Subversion source tree, see
<code>tools/backup/hot-backup.py</code>)

<p>This script also illustrates the safe way to perform a backup of the
repository while it's still up and running: recursively copy the
entire repository directory, then re-copy the logfiles listed by
<code>db_recover -l</code>.

<p>To start using a repository backup that you've restored, be sure to
run <code>db_recover -ve</code> command in the <code>db</code> area first. 
This guarantees that any unfinished log transactions are fully played
before the repository goes live again.

<p>Finally, note that Berkeley DB has a whole locking subsystem; in
extremely intensive svn operations, we have seen situations where the
DB environment runs out of locks.  The maximum number of locks can be
adjusted by changing the values in the <code>repos/db/DB_CONFIG</code>
file.  Don't change the default values unless you know what you're
doing; be sure to read
<a href="http://www.sleepycat.com/docs/ref/lock/max.html">http://www.sleepycat.com/docs/ref/lock/max.html</a> first.

<h4>Tweaking with svnadmin</h4>

<p>The <code>svnadmin</code> tool has some subcommands that are specifically
useful to repository administrators.  Be careful with
<code>svnadmin</code>!  Unlike <code>svnlook</code>, which is read-only,
<code>svnadmin</code> has the ability to modify the repository.

<p>The most-used feature is probably <code>svnadmin setlog</code>.  A
commit's log message is an unversioned property directly attached to
the revision object; there's only one log message per revision. 
Sometimes a user screws up the message, and it needs to be replaced:

<br><pre>$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos 388 newlog.txt
</pre>

<p>There's a nice CGI script in <code>tools/cgi/</code> that allows people
(with commit-access passwords) to tweak existing log messages via web
browser.

<p>Another common use of <code>svnadmin</code> is to inspect and clean up
old, dead transactions.  Commits and updates both create transaction
trees, but occasionally a bug or crash can leave them lying around. 
By inspecting the datestamp on a transaction, an administrator can
make a judgment call and remove it:

<br><pre>$ svnadmin lstxns myrepos
319
321
$ svnadmin lstxns --long myrepos
Transaction 319
Created: 2002-07-14T12:57:22.748388Z
[...]
$ svnadmin rmtxns myrepos 319 321
</pre>

<p>Another useful subcommand: <code>svnadmin undeltify</code>.  Remember
that the latest version of each file is stored as fulltext in the
repository, but that earlier revisions of files are stored as "deltas"
against each next-most-recent revisions.  When a user attempts to
access an earlier revision, the repository must apply a sequence of
backwards-deltas to the newest fulltexts in order to derive the older
data.

<p>If a particular revision tree is extremely popular, the administrator
can speed up the access time to this tree by "undeltifying" any path
within the revision - that is, by converting every file to fulltext:

<br><pre>$ svnadmin undeltify myrepos 230 /project/tags/release-1.3
Undeltifying `/project/tags/release-1.3' in revision 230...done.
</pre>

<p><hr>
Node:<a name="Networking%20a%20repository">Networking a repository</a>,
Next:<a rel=next href="#Migrating%20a%20repository">Migrating a repository</a>,
Previous:<a rel=previous href="#Repository%20maintenance">Repository maintenance</a>,
Up:<a rel=up href="#Repository%20Administration">Repository Administration</a>
<br>

<h3>Networking a repository</h3>

<p>Okay, so now you have a repository, and you want to make it available
over a network.

<p>Subversion's primary network server is Apache httpd speaking
WebDAV/deltaV protocol, which is a set of extension methods to http. 
(For more information on DAV, see <a href="http://www.webdav.org/">http://www.webdav.org/</a>.)

<p>To network your repository, you'll need to

<ul>
<li>get Apache httpd 2.0 up and running with the mod_dav module
<li>install the mod_dav_svn plugin to mod_dav, which uses
Subversion's libraries to access the repository
<li>configure your <code>httpd.conf</code> file to export the repository
</ul>

<p>You can accomplish the first two items by either building httpd and
Subversion from source code, or by installing a binary packages on
your system.  The second appendix of this document contains more
detailed instructions on doing this. (See <a href="#Compiling%20and%20installing">Compiling and installing</a>.)  Instructions are also available in the <code>INSTALL</code>
file in Subversion's source tree.

<p>In this section, we focus on configuring your <code>httpd.conf</code>.

<p>Somewhere near the bottom of your configuration file, define a new
<code>Location</code> block:

<br><pre>&lt;Location /repos&gt;
   DAV svn
   SVNPath /absolute/path/to/myrepos
&lt;/Location&gt;
</pre>

<p>This now makes your repository <code>myrepos</code> available at the URL
&lt;<code>http://hostname/repos</code>&gt;, with no access restrictions at all:

<ul>
<li>Anyone can use their svn client to checkout either a working copy of
the URL, or of any URL that corresponds to a subdirectory of the
repository. 
<li>By pointing an ordinary web browser at the URL, anyone can
interactively browse the latest revision. 
<li>Anyone can commit to the repository. 
</ul>

<p>If you want to restrict either read or write access to the repository
as a whole, you can use Apache's built-in access control features.

<p>First, create an empty file that will hold httpd usernames and
passwords.   Place names and crypted passwords into this file like so:

<br><pre>joe:Msr3lKOsYMkpc
frank:Ety6rZX6P.Cqo
mary:kV4/mQbu0iq82
</pre>

<p>You can generate the crypted passwords by using the standard
<code>crypt(3)</code> command, or using the <code>htpasswd</code> tool
supplied in Apache's <code>bin</code> directory:

<br><pre>$ /usr/local/apache2/bin/htpasswd -n sussman
New password:
Re-type new password:
sussman:kUqncD/TBbdC6
</pre>

<p>Next, add lines within your <code>&lt;Location&gt;</code> block that point to the
user file:

<br><pre>AuthType Basic
AuthName "Subversion repository"
AuthUserFile /path/to/users/file
</pre>

<p>If you want to restrict <em>all</em> access to the repository, add one
more line:

<br><pre>Require valid-user
</pre>

<p>This line make Apache require user authentication for every single
type of http request to your repository.

<p>To restrict write-access only, you need to require a valid user for
all request methods <em>except</em> those that are read-only:

<br><pre>&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
   Require valid-user
&lt;/LimitExcept&gt;
</pre>

<p>Or, if you want to get fancy, you can create two separate user files,
one for readers, and one for writers:

<br><pre>AuthGroupFile /my/svn/group/file

&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
   Require group svn_committers
&lt;/LimitExcept&gt;

&lt;Limit GET PROPFIND OPTIONS REPORT&gt;
   Require group svn_committers
   Require group svn_readers
&lt;/Limit&gt;
</pre>

<p>These are only a few simple examples.  For a complete tutorial on
Apache access control, please consider taking a look at the
"Security" tutorials found at
<a href="http://httpd.apache.org/docs-2.0/misc/tutorials.html">http://httpd.apache.org/docs-2.0/misc/tutorials.html</a>.

<p>Another note: in order for <code>svn cp</code> to work (which is actually
implemented as a DAV COPY request), mod_dav needs to be able to be
able to determine the hostname of the server.  A standard way of doing
this is to use Apache's ServerName directive to set the server's
hostname.  Edit your <code>httpd.conf</code> to include:

<br><pre>ServerName svn.myserver.org
</pre>

<p>If you are using virtual hosting through Apache's <code>NameVirtualHost</code>
directive, you may need to use the <code>ServerAlias</code> directive to specify
additional names that your server is known by.

<p>(If you are unfamiliar with an Apache directive, or not exactly sure
about what it does, don't hesitate to look it up in the documentation:
<a href="http://httpd.apache.org/docs-2.0/mod/directives.html">http://httpd.apache.org/docs-2.0/mod/directives.html</a>.)

<p>You can test your exported repository by firing up httpd:

<br><pre>$ /usr/local/apache2/bin/apachectl stop
$ /usr/local/apache2/bin/apachectl start
</pre>

<p>Check <code>/usr/local/apache2/logs/error_log</code> to make sure it started up
okay.  Try doing a network checkout from the repository:

<br><pre>$ svn co http://localhost/repos wc
</pre>

<p>The most common reason this might fail is permission problems reading
the repository db files.  Make sure that the user "nobody" (or
whatever UID the httpd process runs as) has permission to read and
write the Berkeley DB files!  This is a very common problem.

<p>You can see all of mod_dav_svn's complaints in the Apache error
logfile, <code>/usr/local/apache2/logs/error_log</code>, or wherever you
installed Apache.  For more information about tracing problems, see
"Debugging the server" in the <code>HACKING</code> file.

<p><hr>
Node:<a name="Migrating%20a%20repository">Migrating a repository</a>,
Next:<a rel=next href="#WebDAV">WebDAV</a>,
Previous:<a rel=previous href="#Networking%20a%20repository">Networking a repository</a>,
Up:<a rel=up href="#Repository%20Administration">Repository Administration</a>
<br>

<h3>Migrating a repository</h3>

<p>Sometimes special situations arise where you need to move all of your
filesystem data from one repository to another.  Perhaps the internal
fs database schema has changed in some way in a new release of
Subversion, or perhaps you'd like to start using a different database
"back end".

<p>Either way, your data needs to be migrated to a new repository.  To do
this, we have the <code>svnadmin dump</code> and <code>svnadmin load</code>
commands.

<p><code>svnadmin dump</code> writes a stream of your repository's data to
stdout:

<br><pre>$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
[...]
</pre>

<p>This stream describes every revision in your repository as a list of
changes to nodes.  It's mostly human-readable text; but when a file's
contents change, the entire fulltext is dumped into the stream.  If
you have binary files or binary property-values in your repository,
those parts of the stream may be unfriendly to human readers.

<p>After dumping your data, you would then move the file to a different
system (or somehow alter the environment to use a different version of
<code>svnadmin</code> and/or <code>libsvn_fs.so</code>), and create a
"new"-style repository that has a new schema or DB back-end:

<br><pre>$ svnadmin create newrepos
</pre>

<p>The <code>svnadmin load</code> command attempts to read a dumpstream from
stdin, and effectively replays each commit:

<br><pre>$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
[...]
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;
</pre>

<p>Voila, your revisions have been recommitted into the new repository.

<h4>Stupid dump/load tricks</h4>

<p>People who are feeling saucy with Unix can try things like this:

<br><pre>$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</pre>

<p>Also, it's possible to create a series of smaller dumpfiles and load
them in succession (say, if a single dumpfile is too large to fit on
backup or transport medium.)  But it requires a small bit of hackery:

<br><pre>$ svnadmin dump myrepos 0 2000 &gt; dumpfile1
$ svnadmin dump myrepos 2000 4000 &gt; dumpfile2
</pre>

<p>So now you have two dumpfiles; the first contains revisions 0-2000,
and the second contains revisions 2000-4000.  Why the overlap?

<p>Here's why.  The first revision dumped by <code>svnadmin dump</code> is
always compared against revision 0, which is just the empty root
directory <code>/</code>.  That means that the first revision an any
dumpfile will always look like a gigantic list of "added" nodes.  We
do this so that a file like <code>dumpfile2</code> can be directly loaded
into an empty repository.

<p>But there's a flip side to this nicety.  When we want to load a number
of dumpfiles in sequence, we need to make sure each file overlaps by
at least one revision.  Before loading, the first revision of a file
like <code>dumpfile2</code> needs to be <em>removed</em>, so that the file
begins with a description of revision 2001 as a tree-delta against
revision 2000:

<ul>
<li>open the <code>dumpfile2</code> in an editor
<li>do <em>not</em> remove the <code>SVN-fs-dump-format-version</code> header line
at the beginning of the file
<li><em>do</em> remove the first revision, which begins with a
<code>Revision-number:</code> record, and goes all the way until the next
<code>Revision-number:</code> block. 
</ul>

<p>Once your dumpfiles have all been properly trimmed, you can load them
in sequence:

<br><pre>$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
</pre>

<p><hr>
Node:<a name="WebDAV">WebDAV</a>,
Previous:<a rel=previous href="#Migrating%20a%20repository">Migrating a repository</a>,
Up:<a rel=up href="#Repository%20Administration">Repository Administration</a>
<br>

<h3>WebDAV</h3>

<p>Subversion uses WebDAV (Distributed Authoring and Versioning) as its
primary network protocol, and here we discuss what this means to you,
both present and future.

<p>WebDAV was designed to make the web into a read/write medium, instead
of a read-only medium (as it mainly exists today.)  The theory is that
directories and files can be shared over the web, using standardized
extensions to HTTP.  RFC 2518 describes the WebDAV extensions to HTTP,
and is available (along with a lot of other useful information) at
<a href="http://www.webdav.org/">http://www.webdav.org/</a>.

<p>Already, a number of operating system file-browsers are able to mount
networked directories using WebDAV.  On Win32, the Windows Explorer
can browse what it calls "WebFolders", just like any other share. 
Mac OS X also has this capability, as does the Nautilus browser for
GNOME.

<p>However, RFC 2518 doesn't fully implement the "versioning" aspect of
WebDAV.  A separate committee has created RFC 3253, known as the
<dfn>DeltaV</dfn> extensions to WebDAV, available at
<a href="http://www.webdav.org/deltav/">http://www.webdav.org/deltav/</a>.   These extensions add
version-control concepts to HTTP, and this is what Subversion uses.

<p>It's important to understand that while Subversion uses DeltaV for
communication, the Subversion client is <em>not</em> a general-purpose
DeltaV client. In fact, it expects some custom features from the
server. Further, the Subversion server is not a general-purpose DeltaV
server. It implements a strict subset of the DeltaV specification. A
WebDAV or DeltaV client may very well be able to interoperate with it,
but only if that client operates within the narrow confines of those
features the server has implemented. Future versions of Subversion
will address more complete WebDAV interoperability.

<p>At the moment, most DAV browsers and clients do not yet support
DeltaV; this means that a Subversion repository can viewed or mounted
only as a read-only resource.  (An HTTP "PUT" request is valid when
sent to a WebDAV-only server, but a DeltaV server such as mod_dav_svn
will not allow it.  The client must use special version-control
methods to write to the server.)  And on the flip side, a Subversion
client cannot checkout a working copy from a generic WebDAV server; it
expects a specific subset of DeltaV features.

<p>For a detailed description of Subversion's WebDAV implementation, see
<a href="http://svn.collab.net/repos/svn-repos/trunk/www/webdav-usage.html">http://svn.collab.net/repos/svn-repos/trunk/www/webdav-usage.html</a>.

<p><hr>
Node:<a name="Appendices">Appendices</a>,
Previous:<a rel=previous href="#Repository%20Administration">Repository Administration</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h2>Appendices</h2>

<p>A number of other useful documents relevant to Subversion.

<ul>
<li><a href="#SVN%20for%20CVS%20users">SVN for CVS users</a>: 
<li><a href="#Directory%20versioning">Directory versioning</a>: 
<li><a href="#Compiling%20and%20installing">Compiling and installing</a>: 
<li><a href="#Quick%20reference%20sheet">Quick reference sheet</a>: 
<li><a href="#FAQ">FAQ</a>: 
<li><a href="#Contributing">Contributing</a>: 
<li><a href="#License">License</a>: 
</ul>

<p><hr>
Node:<a name="SVN%20for%20CVS%20users">SVN for CVS users</a>,
Next:<a rel=next href="#Directory%20versioning">Directory versioning</a>,
Up:<a rel=up href="#Appendices">Appendices</a>
<br>

<h3>SVN for CVS users</h3>

<p>This document is meant to be a quick-start guide for CVS users new to
Subversion.  It's not a substitute for real documentation and manuals;
but it should give you a quick conceptual "diff" when switching over.

<p>The goal of Subversion is to take over the current and future CVS user
base.  Subversion not only includes new features, but attempts to fix
certain "broken" behaviors that CVS had.  This means that you may be
encouraged to break certain habits - ones that you forgot were odd to
begin with.

<ul>
<li><a href="#Revision%20numbers%20are%20different%20now">Revision numbers are different now</a>: 
<li><a href="#More%20disconnected%20operations">More disconnected operations</a>: 
<li><a href="#Distinction%20between%20status%20and%20update">Distinction between status and update</a>: 
<li><a href="#Meta-data%20properties">Meta-data properties</a>: 
<li><a href="#Directory%20versions">Directory versions</a>: 
<li><a href="#Conflicts">Conflicts</a>: 
<li><a href="#Binary%20files">Binary files</a>: 
<li><a href="#Authorization">Authorization</a>: 
<li><a href="#Versioned%20Modules">Versioned Modules</a>: 
<li><a href="#Branches%20and%20tags">Branches and tags</a>: 
</ul>

<p><hr>
Node:<a name="Revision%20numbers%20are%20different%20now">Revision numbers are different now</a>,
Next:<a rel=next href="#More%20disconnected%20operations">More disconnected operations</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Revision numbers are different now</h4>

<p>In CVS, revision numbers are per-file.  This is because CVS uses RCS
as a backend; each file has a corresponding RCS file in the
repository, and the repository is roughly laid out according to
structure of your project tree.

<p>In Subversion, the repository looks like a single filesystem.  Each
commit results in an entirely new filesystem tree; in essence, the
repository is an array of trees.  Each of these trees is labeled with
a single revision number.  When someone talks about "revision 54,"
they're talking about a particular tree (and indirectly, the way the
filesystem looked after the 54th commit).

<p>Technically, it's not valid to talk about "revision 5 of <code>foo.c</code>". 
Instead, one would say "<code>foo.c</code> as it appears in revision 5." 
Also, be careful when making assumptions about the evolution of a file. 
In CVS, revisions 5 and 6 of <code>foo.c</code> are always different.  In
Subversion, it's most likely that <code>foo.c</code> did *not* change between
revisions 5 and 6.

<p><hr>
Node:<a name="More%20disconnected%20operations">More disconnected operations</a>,
Next:<a rel=next href="#Distinction%20between%20status%20and%20update">Distinction between status and update</a>,
Previous:<a rel=previous href="#Revision%20numbers%20are%20different%20now">Revision numbers are different now</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>More disconnected operations</h4>

<p>In recent years, disk space has become outrageously cheap and
abundant, but network bandwidth has not.  Therefore, the Subversion
working copy has been optimized around the scarcer resource.

<p>The <code>.svn</code> administrative directory serves the same purpose as the
<code>CVS</code> directory, except that it also stores "pristine" copies of files. 
This allows you to do many things off-line:

<ul>
<li><code>svn status</code>
shows you local modifications (see below)
<li><code>svn diff</code>
shows you the details of your modifications
<li><code>svn ci</code>
sends differences to the repository (CVS only sends fulltexts!) 
<li><code>svn revert</code>
removes your modifications
</ul>

<p>This last subcommand is new; it will not only remove local mods, but
it will un-schedule operations such as adds and deletes.  It's the
preferred way to revert a file; running <code>rm file; svn up</code> will
still work, but it blurs the purpose of updating.  And, while we're on
this subject...

<p><hr>
Node:<a name="Distinction%20between%20status%20and%20update">Distinction between status and update</a>,
Next:<a rel=next href="#Meta-data%20properties">Meta-data properties</a>,
Previous:<a rel=previous href="#More%20disconnected%20operations">More disconnected operations</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Distinction between status and update</h4>

<p>In Subversion, we've tried to erase a lot of the confusion between the
<code>status</code> and <code>update</code> subcommands.

<p>The <code>status</code> command has two purposes: (1) to show the user any local
modifications in the working copy, and (2) to show the user which
files are out-of-date.  Unfortunately, because of CVS's hard-to-read
output, many CVS users don't take advantage of this command at all. 
Instead, they've developed a habit of running <code>cvs up</code> to quickly see
their mods.  Of course, this has the side effect of merging repository
changes that you may not be ready to deal with!

<p>With Subversion, we've tried to remove this muddle by making the
output of <code>svn status</code> easy to read for humans and parsers.  Also,
<code>svn update</code> only prints information about files that are updated,
<em>not</em> local modifications.

<p>Here's a quick guide to <code>svn status</code>.  We encourage all new
Subversion users to use it early and often:

<ul>
<li><code>svn status</code>
prints all files that have local modifications; the network is not
accessed by default.
<ul>
<li><code>-u</code> switch
add out-of-dateness information from repository
<li><code>-v</code> switch
show <em>all</em> entries under version control
<li><code>-n</code> switch
nonrecursive
</ul>
</ul>

<p>The status command has two output formats.  In the default "short"
format, local modifications look like this:

<br><pre>    % svn status
    M     ./foo.c
    M     ./bar/baz.c
</pre>

<p>If you specify either the <code>-u</code> or <code>-v</code> switch, a "long"
format is used:

<br><pre>    % svn status
    M             1047    ./foo.c
    _      *      1045    ./faces.html
    _      *         -    ./bloo.png
    M             1050    ./bar/baz.c
    Head revision:   1066
</pre>

<p>In this case, two new columns appear.  The second column
contains an asterisk if the file or directory is
out-of-date.  The third column shows the working-copy's revision
number of the item.  In the example above, the asterisk indicates that
<code>faces.html</code> would be patched if we updated, and that
<code>bloo.png</code> is a newly added file in the repository.  (The <code>-</code> next
to bloo.png means that it doesn't yet exist in the working copy.)

<p>Lastly, here's a quick summary of status codes that you may see:

<br><pre>   A    Add
   D    Delete
   R    Replace  (delete, then re-add)
   M    local Modification
   U    Updated
   G    merGed
   C    Conflict
</pre>

<p>Subversion has combined the CVS <code>P</code> and <code>U</code> codes into just
<code>U</code>.  When a merge or conflict occurs, Subversion simply prints
<code>G</code> or <code>C</code>, rather than a whole sentence about it.

<p><hr>
Node:<a name="Meta-data%20properties">Meta-data properties</a>,
Next:<a rel=next href="#Directory%20versions">Directory versions</a>,
Previous:<a rel=previous href="#Distinction%20between%20status%20and%20update">Distinction between status and update</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Meta-data properties</h4>

<p>A new feature of Subversion is that you can attach arbitrary metadata to
files and directories.  We refer to this data as <dfn>properties</dfn>, and
they can be thought of as collections of name/value pairs (hashtables)
attached to each item in your working copy.

<p>To set or get a property name, use the <code>svn propset</code> and <code>svn
propget</code> subcommands.  To list all properties on an object, use
<code>svn proplist</code>.

<p>For more information, See <a href="#Properties">Properties</a>.

<p><hr>
Node:<a name="Directory%20versions">Directory versions</a>,
Next:<a rel=next href="#Conflicts">Conflicts</a>,
Previous:<a rel=previous href="#Meta-data%20properties">Meta-data properties</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Directory versions</h4>

<p>Subversion tracks tree structures, not just file contents.  It's one
of the biggest reasons Subversion was written to replace CVS.

<p>Here's what this means to you:

<ul>
<li>the <code>svn add</code> and <code>svn rm</code> commands work on directories now, just as
they work on files.  So do <code>svn cp</code> and <code>svn mv</code>.  However, these
commands do *not* cause any kind of immediate change in the
repository.  Instead, the working directory is recursively "scheduled"
for addition or deletion.  No repository changes happen until you
commit. 
<li>Directories aren't dumb containers anymore; they have revision
numbers like files.  (Or more properly, it's correct to talk
about "directory <code>foo/</code> in revision 5".) 
</ul>

<p>Let's talk more about that last point.  Directory versioning is a Hard
Problem.  Because we want to allow mixed-revision working copies,
there are some limitations on how far we can abuse this model.

<p>From a theoretical point of view, we define "revision 5 of directory
<code>foo</code>" to mean a specific collection of directory-entries and
properties.  Now suppose we start adding and removing files from <code>foo</code>,
and then commit.  It would be a lie to say that we still have revision
5 of <code>foo</code>.  However, if we bumped <code>foo</code>'s revision number after the
commit, that would be a lie too; there may be other changes to <code>foo</code> we
haven't yet received, because we haven't updated yet.

<p>Subversion deals with this problem by quietly tracking committed adds
and deletes in the <code>.svn</code> area.  When you eventually run <code>svn
update</code>, all accounts are settled with the repository, and the directory's new
revision number is set correctly.  <b>Therefore, only after an update is
it truly safe to say that you have a "perfect" revision of a directory.</b>
Most of the time, your working copy will contain "imperfect" directory
revisions.

<p>Similarly, a problem arises if you attempt to commit property changes on
a directory.  Normally, the commit would bump the working directory's
local revision number.  But again, that would be a lie, because there
may be adds or deletes that the directory doesn't yet have, because no
update has happened.  <b>Therefore, you are not allowed to commit
property-changes on a directory unless the directory is up-to-date.</b>

<p>For more specific examples and discussion: See <a href="#Directory%20versioning">Directory versioning</a>.

<p><hr>
Node:<a name="Conflicts">Conflicts</a>,
Next:<a rel=next href="#Binary%20files">Binary files</a>,
Previous:<a rel=previous href="#Directory%20versions">Directory versions</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Conflicts</h4>

<p>CVS marks conflicts with in-line "conflict markers", and prints a <code>C</code>
during an update.  Historically, this has caused problems.  Many users
forget about (or don't see) the <code>C</code> after it whizzes by on their
terminal.  They often forget that the conflict-markers are even
present, and then accidentally commit garbaged files.

<p>Subversion solves this problem by making conflicts more tangible. 
Read about it: See <a href="#Basic%20Work%20Cycle">Basic Work Cycle</a>.  In particular, read the
section about "Merging others' changes".

<p><hr>
Node:<a name="Binary%20files">Binary files</a>,
Next:<a rel=next href="#Authorization">Authorization</a>,
Previous:<a rel=previous href="#Conflicts">Conflicts</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Binary files</h4>

<p>CVS users have to mark binary files with <code>-kb</code> flags, to prevent data
from being munged (due to keyword expansion and line-ending
translations).  They sometimes forget to do this.

<p>Subversion examines the <code>svn:mime-type</code> property to decide if a file
is text or binary.  If the file has no <code>svn:mime-type</code> property,
Subversion assumes it is text.  If the file has the <code>svn:mime-type</code>
property set to anything other than <code>text/*</code>, it assumes the file is
binary.

<p>Subversion also helps users by running a binary-detection algorithm in
the <code>svn import</code> and <code>svn add</code> subcommands.  These subcommands will
make a good guess and then (possibly) set a binary <code>svn:mime-type</code>
property on the file being added.  (If Subversion guesses wrong, you
can always remove or hand-edit the property.)

<p>As in CVS, binary files are not subject to keyword expansion or
line-ending conversions.  Also, when a binary file is "merged" during
update, no real merge occurs.  Instead, Subversion creates two files
side-by-side in your working copy; the one containing your local
modifications is renamed with an <code>.orig</code> extension.

<p><hr>
Node:<a name="Authorization">Authorization</a>,
Next:<a rel=next href="#Versioned%20Modules">Versioned Modules</a>,
Previous:<a rel=previous href="#Binary%20files">Binary files</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Authorization</h4>

<p>Unlike CVS, SVN can handle anonymous and authorized users in the same
repository.  There is no need for an anonymous user or a separate
repository.  If the SVN server requests authorization when committing,
the client should prompt you for your authorization (password).

<p><hr>
Node:<a name="Versioned%20Modules">Versioned Modules</a>,
Next:<a rel=next href="#Branches%20and%20tags">Branches and tags</a>,
Previous:<a rel=previous href="#Authorization">Authorization</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Versioned Modules</h4>

<p>Unlike CVS, a Subversion working copy is aware that it has checked out
a module.  That means that if somebody changes the definition of a
module, then a call to <code>svn up</code> will update the working copy
appropriately.

<p>Subversion defines modules as a list of directories within a directory
property.  See <a href="#Modules">Modules</a>.

<p><hr>
Node:<a name="Branches%20and%20tags">Branches and tags</a>,
Previous:<a rel=previous href="#Versioned%20Modules">Versioned Modules</a>,
Up:<a rel=up href="#SVN%20for%20CVS%20users">SVN for CVS users</a>
<br>

<h4>Branches and tags</h4>

<p>Subversion doesn't distinguish between filesystem space and "branch"
space; branches and tags are ordinary directories within the
filesystem.  This is probably the single biggest mental hurdle a CVS
user will need to climb.  Read all about it: See <a href="#Branches%20and%20Tags">Branches and Tags</a>.

<p><hr>
Node:<a name="Directory%20versioning">Directory versioning</a>,
Next:<a rel=next href="#Compiling%20and%20installing">Compiling and installing</a>,
Previous:<a rel=previous href="#SVN%20for%20CVS%20users">SVN for CVS users</a>,
Up:<a rel=up href="#Appendices">Appendices</a>
<br>

<h3>Directory versioning</h3>

<blockquote>
<em>"The three cardinal virtues of a master technologist are:
laziness, impatience, and hubris." - Larry Wall</em>
</blockquote>

<p>This appendix describes some of the theoretical pitfalls around the
(possibly arrogant) notion that one can simply version directories
just as one versions files.

<h4>Directory Revisions</h4>

<p>To begin, recall that the Subversion repository is an array of trees. 
Each tree represents the application of a new atomic commit, and is
called a <dfn>revision</dfn>.  This is very different from a CVS repository,
which stores file histories in a collection of RCS files (and doesn't
track tree-structure.)

<p>So when we refer to "revision 4 of <code>foo.c</code>" (written <dfn>foo.c:4</dfn>) in
CVS, this means the fourth distinct version of <code>foo.c</code> - but in
Subversion this means "the version of <code>foo.c</code> in the fourth revision
(tree)".  It's quite possible that <code>foo.c</code> has never changed at all
since revision 1!  In other words, in Subversion, different revision
numbers of the same versioned item do <em>not</em> imply different
contents.

<p>Nevertheless, the contents of <code>foo.c:4</code> is still well-defined.  The
file <code>foo.c</code> in revision 4 has a specific text and properties.

<p>Suppose, now, that we extend this concept to directories.  If we have a
directory <code>DIR</code>, define <dfn>DIR:N</dfn> to be "the directory DIR in the
fourth revision."  The contents are defined to be a particular set of
directory entries (<dfn>dirents</dfn>) and properties.

<p>So far, so good.  The concept of versioning directories seems fine in
the repository - the repository is very theoretically pure anyway. 
However, because working copies allow mixed revisions, it's easy to
create problematic use-cases.

<h4>The Lagging Directory</h4>

<h5>Problem</h5>

<p>Suppose our working copy has directory <code>DIR:1</code> containing file
<code>foo:1</code>, along with some other files.  We remove <code>foo</code> and
commit.

<p>Already, we have a problem: our working copy still claims to have
<code>DIR:1</code>.  But on the repository, revision 1 of <code>DIR</code> is
<em>defined</em> to contain <code>foo</code> - and our working copy <code>DIR</code> clearly
does not have it anymore.  How can we truthfully say that we still have
<code>DIR:1</code>?

<p>One answer is to force <code>DIR</code> to be updated when we commit
<code>foo</code>'s deletion.  Assuming that our commit created revision 2, we
would immediately update our working copy to <code>DIR:2</code>.  Then the
client and server would both agree that <code>DIR:2</code> does not contain
foo, and that <code>DIR:2</code> is indeed exactly what is in the working
copy.

<p>This solution has nasty, un-user-friendly side effects, though.  It's
likely that other people may have committed before us, possibly adding
new properties to <code>DIR</code>, or adding a new file <code>bar</code>.  Now pretend our
committed deletion creates revision 5 in the repository.  If we
instantly update our local <code>DIR</code> to 5, that means unexpectedly receiving a
copy of <code>bar</code> and some new propchanges.  This clearly violates a UI
principle: "the client will never change your working copy until you ask
it to."  Committing changes to the repository is a server-write
operation only; it should <em>not</em> modify your working data!

<p>Another solution is to do the naive thing: after committing the
deletion of <code>foo</code>, simply stop tracking the file in the <code>.svn</code>
administrative directory.  The client then loses all knowledge of the
file.

<p>But this doesn't work either: if we now update our working copy, the
communication between client and server is incorrect.  The client still
believes that it has <code>DIR:1</code> - which is false, since a "true"
<code>DIR:1</code> contains <code>foo</code>.  The client gives this incorrect
report to the repository, and the repository decides that in order to
update to revision 2, <code>foo</code> must be deleted.  Thus the repository
sends a bogus (or at least unnecessary) deletion command.

<h5>Solution</h5>

<p>After deleting <code>foo</code> and committing, the file is <em>not</em>
totally forgotten by the <code>.svn</code> directory.  While the file is no
longer considered to be under revision control, it is still secretly
remembered as having been `deleted'.

<p>When the user updates the working copy, the client correctly informs the
server that the file is already missing from its local <code>DIR:1</code>;
therefore the repository doesn't try to re-delete it when patching the
client up to revision 2.

<h4>The Overeager Directory</h4>

<h5>Problem</h5>

<p>Again, suppose our working copy has directory <code>DIR:1</code> containing
file <code>foo:1</code>, along with some other files.

<p>Now, unbeknownst to us, somebody else adds a new file <code>bar</code> to this
directory, creating revision 2 (and <code>DIR:2</code>).

<p>Now we add a property to <code>DIR</code> and commit, which creates revision
3.  Our working-copy <code>DIR</code> is now marked as being at revision 3.

<p>Of course, this is false; our working copy does <em>not</em> have
<code>DIR:3</code>, because the "true" <code>DIR:3</code> on the repository contains
the new file <code>bar</code>.  Our working copy has no knowledge of
<code>bar</code> at all.

<p>Again, we can't follow our commit of <code>DIR</code> with an automatic update
(and addition of <code>bar</code>).  As mentioned previously, commits are a
one-way write operation; they must not change working copy data.

<h5>Solution</h5>

<p>Let's enumerate exactly those times when a directory's local revision
number changes:

<ul>
<li><b>when a directory is updated</b>: if the directory is either the direct
target of an update command, or is a child of an updated directory, it
will be bumped (along with many other siblings and children) to a
uniform revision number. 
<li><b>when a directory is committed</b>: a directory can only be considered a
"committed object" if it has a new property change.  (Otherwise, to
"commit a directory" really implies that its modified children are being
committed, and only such children will have local revisions bumped.) 
</ul>

<p>In this light, it's clear that our "overeager directory" problem only
happens in the second situation - those times when we're committing
directory propchanges.

<p>Thus the answer is simply not to allow property-commits on directories
that are out-of-date.  It sounds a bit restrictive, but there's no other
way to keep directory revisions accurate.

<h4>User impact</h4>

<p>Really, the Subversion client seems to have two difficult--almost
contradictory--goals.

<p>First, it needs to make the user experience friendly, which generally
means being a bit "sloppy" about deciding what a user can or cannot do. 
This is why it allows mixed-revision working copies, and why it tries to
let users execute local tree-changing operations (delete, add, move,
copy) in situations that aren't always perfectly, theoretically "safe"
or pure.

<p>Second, the client tries to keep the working copy in correctly in sync
with the repository using as little communication as possible.  Of
course, this is made much harder by the first goal!

<p>So in the end, there's a tension here, and the resolutions to problems
can vary.  In one case (the "lagging directory"), the problem can be
solved through a bit of clever entry tracking in the client.  In the
other case ("the overeager directory"), the only solution is to
restrict some of the theoretical laxness allowed by the client.

<p><hr>
Node:<a name="Compiling%20and%20installing">Compiling and installing</a>,
Next:<a rel=next href="#Quick%20reference%20sheet">Quick reference sheet</a>,
Previous:<a rel=previous href="#Directory%20versioning">Directory versioning</a>,
Up:<a rel=up href="#Appendices">Appendices</a>
<br>

<h3>Compiling and installing</h3>

<p>The latest instructions for compiling and installing Subversion (and
httpd-2.0) are maintained in the <code>INSTALL</code> file at the top of the
Subversion source tree.

<p>In general, you should also be able to find the latest version of this
file by grabbing it directly from Subversion's own repository:
<a href="http://svn.collab.net/repos/svn/trunk/INSTALL">http://svn.collab.net/repos/svn/trunk/INSTALL</a>

<p><hr>
Node:<a name="Quick%20reference%20sheet">Quick reference sheet</a>,
Next:<a rel=next href="#FAQ">FAQ</a>,
Previous:<a rel=previous href="#Compiling%20and%20installing">Compiling and installing</a>,
Up:<a rel=up href="#Appendices">Appendices</a>
<br>

<h3>Quick reference sheet</h3>

<p>A latex quick-reference sheet exists on Subversion's website for
download, which is compiled from the source file in
<code>doc/user/svn-ref.tex</code> directory.  Any volunteers to rewrite it here
in texinfo?

<p><hr>
Node:<a name="FAQ">FAQ</a>,
Next:<a rel=next href="#Contributing">Contributing</a>,
Previous:<a rel=previous href="#Quick%20reference%20sheet">Quick reference sheet</a>,
Up:<a rel=up href="#Appendices">Appendices</a>
<br>

<h3>FAQ</h3>

<p>The main FAQ for the project can viewed directly in Subversion's
repository:

<a href="http://svn.collab.net/repos/svn/trunk/www/project_faq.html">http://svn.collab.net/repos/svn/trunk/www/project_faq.html</a>

<p><hr>
Node:<a name="Contributing">Contributing</a>,
Next:<a rel=next href="#License">License</a>,
Previous:<a rel=previous href="#FAQ">FAQ</a>,
Up:<a rel=up href="#Appendices">Appendices</a>
<br>

<h3>Contributing</h3>

<p>For a full description of how to contribute to Subversion, read the
<code>HACKING</code> file at the top of Subversion's source tree.  It's also
available at <a href="http://svn.collab.net/repos/svn/trunk/HACKING">http://svn.collab.net/repos/svn/trunk/HACKING</a>.

<p>In a nutshell: Subversion behaves like many open-source projects.  One
begins by participating in discussion on mailing lists, then by
submitting patches for review.  Eventually, rights are granted direct
commit access to the repository.

<p><hr>
Node:<a name="License">License</a>,
Previous:<a rel=previous href="#Contributing">Contributing</a>,
Up:<a rel=up href="#Appendices">Appendices</a>
<br>

<h3>License</h3>

<p>Copyright &copy; 2002 Collab.Net.  All rights reserved.

<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

<ol type=1 start=1>
</p><li>Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

<li>Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

<li>The end-user documentation included with the redistribution, if
any, must include the following acknowledgment: "This product includes
software developed by CollabNet (<a href="http://www.Collab.Net/">http://www.Collab.Net/</a>)." 
Alternately, this acknowledgment may appear in the software itself, if
and wherever such third-party acknowledgments normally appear.

<li>The hosted project names must not be used to endorse or promote
products derived from this software without prior written
permission. For written permission, please contact info@collab.net.

<li>Products derived from this software may not use the "Tigris" name
nor may "Tigris" appear in their names without prior written
permission of CollabNet.

<li>THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
IN NO EVENT SHALL COLLABNET OR ITS CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</ol>

<p>This software consists of voluntary contributions made by many
individuals on behalf of CollabNet.

<hr><h4>Footnotes</h4>
<ol type="1">
<li><a name="fn-1"></a>
<p>For example: the C routine `svn_client_checkout()'
takes a URL as an argument.  It passes this URL to the repository-access
library and opens an authenticated session with a particular repository. 
It then asks the repository for a certain tree, and sends this tree into
the working-copy library, which then writes a full working copy to disk
(.svn directories and all.)</p>

<li><a name="fn-2"></a>
<p>Why read-only?  Because if a
pre-commit hook script changed the transaction before commit, the
working copy would have no way of knowing what happened, and would
therefore be out of sync and not know it.  Subversion currently has no
way to handle this situation, and maybe never will.</p>

<li><a name="fn-3"></a>
<p>At this time, this is the only method by which
users can implement finer-grained access control beyond what
<code>httpd.conf</code> offers.  In a future version of Subversion, we plan to
implement ACLs directly in the filesystem.</p>

</ol><hr>

</body></html>
