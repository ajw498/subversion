Index: subversion/include/svn_ra_svn.h
===================================================================
--- subversion/include/svn_ra_svn.h	(revision 12628)
+++ subversion/include/svn_ra_svn.h	(working copy)
@@ -107,6 +107,7 @@
 svn_ra_svn_conn_t *svn_ra_svn_create_conn(apr_socket_t *sock,
                                           apr_file_t *in_file,
                                           apr_file_t *out_file,
+                                          void *ssh_handle,
                                           apr_pool_t *pool);
 
 /** Initialize a connection's capabilities to the ones specified in
Index: subversion/include/svn_props.h
===================================================================
--- subversion/include/svn_props.h	(revision 12628)
+++ subversion/include/svn_props.h	(working copy)
@@ -179,6 +179,9 @@
 /** Set to either TRUE or FALSE if we want a file to be executable or not. */
 #define SVN_PROP_EXECUTABLE  SVN_PROP_PREFIX "executable"
 
+#define SVN_PROP_FILETYPE  SVN_PROP_PREFIX "riscosfiletype"
+
+
 /** The value to force the executable property to when set */
 #define SVN_PROP_EXECUTABLE_VALUE "*"
 
Index: subversion/include/svn_io.h
===================================================================
--- subversion/include/svn_io.h	(revision 12628)
+++ subversion/include/svn_io.h	(working copy)
@@ -275,6 +275,10 @@
                                          svn_boolean_t ignore_enoent,
                                          apr_pool_t *pool);
 
+svn_error_t *svn_io_set_file_filetype (const char *path,
+                                       const svn_string_t *filetype,
+                                       apr_pool_t *pool);
+
 /** Determine whether a file is executable by the current user.  
  * Set @a *executable to @c TRUE if the file @a path is executable by the 
  * current user, otherwise set it to @c FALSE.  
@@ -285,6 +289,9 @@
                                        const char *path, 
                                        apr_pool_t *pool);
 
+svn_error_t *svn_io_get_file_filetype(svn_string_t **filetype,
+                                      const char *path,
+                                      apr_pool_t *pool);
 
 /** Read a line from @a file into @a buf, but not exceeding @a *limit bytes.
  * Does not include newline, instead '\\0' is put there.
Index: subversion/libsvn_wc/merge.c
===================================================================
--- subversion/libsvn_wc/merge.c	(revision 12628)
+++ subversion/libsvn_wc/merge.c	(working copy)
@@ -376,6 +376,9 @@
   if (! dry_run)
     SVN_ERR (svn_wc__maybe_set_executable (NULL, merge_target, adm_access,
                                            pool));
+  if (! dry_run)
+    SVN_ERR (svn_wc__maybe_set_filetype (NULL, merge_target, adm_access,
+                                         pool));
 
   return SVN_NO_ERROR;
 }
Index: subversion/libsvn_wc/translate.h
===================================================================
--- subversion/libsvn_wc/translate.h	(revision 12628)
+++ subversion/libsvn_wc/translate.h	(working copy)
@@ -106,6 +106,11 @@
                               const char *path,
                               svn_wc_adm_access_t *adm_access,
                               apr_pool_t *pool);
+svn_error_t *
+svn_wc__maybe_set_filetype (svn_boolean_t *did_set,
+                            const char *path,
+                            svn_wc_adm_access_t *adm_access,
+                            apr_pool_t *pool);
 
 #ifdef __cplusplus
 }
Index: subversion/libsvn_wc/props.c
===================================================================
--- subversion/libsvn_wc/props.c	(revision 12628)
+++ subversion/libsvn_wc/props.c	(working copy)
@@ -902,6 +902,7 @@
                                   SVN_PROP_EXTERNALS,
                                   NULL };
   const char *dir_prohibit[] = { SVN_PROP_EXECUTABLE,
+                                 SVN_PROP_FILETYPE,
                                  SVN_PROP_KEYWORDS,
                                  SVN_PROP_EOL_STYLE,
                                  SVN_PROP_MIME_TYPE,
@@ -1078,6 +1079,11 @@
         }
     }
 
+  if (kind == svn_node_file && strcmp (name, SVN_PROP_FILETYPE) == 0)
+    {
+        SVN_ERR (svn_io_set_file_filetype (path, value, pool));
+    }
+
   err = svn_wc_prop_list (&prophash, path, adm_access, pool);
   if (err)
     return
Index: subversion/libsvn_wc/adm_crawler.c
===================================================================
--- subversion/libsvn_wc/adm_crawler.c	(revision 12628)
+++ subversion/libsvn_wc/adm_crawler.c	(working copy)
@@ -100,6 +100,7 @@
 
   /* If necessary, tweak the new working file's executable bit. */
   SVN_ERR (svn_wc__maybe_set_executable (NULL, file_path, adm_access, pool));
+  SVN_ERR (svn_wc__maybe_set_filetype (NULL, file_path, adm_access, pool));
 
   /* Remove any text conflict */
   SVN_ERR (svn_wc_resolved_conflict (file_path, adm_access, TRUE, FALSE, FALSE,
Index: subversion/libsvn_wc/log.c
===================================================================
--- subversion/libsvn_wc/log.c	(revision 12628)
+++ subversion/libsvn_wc/log.c	(working copy)
@@ -135,8 +135,10 @@
                                                 pool));
 
         /* After copying, set the file executable if props dictate. */
-        return svn_wc__maybe_set_executable (NULL, full_dest_path, adm_access,
-                                             pool);
+        SVN_ERR (svn_wc__maybe_set_executable (NULL, full_dest_path, adm_access,
+                                               pool));
+        return svn_wc__maybe_set_filetype (NULL, full_dest_path, adm_access,
+                                           pool);
       }
 
     case svn_wc__xfer_cp_and_detranslate:
@@ -304,6 +306,10 @@
        its timestamp, which is the point of returning this flag. :-) */
     *overwrote_working = TRUE;
 
+  SVN_ERR (svn_wc__maybe_set_filetype (&did_set, filepath, adm_access, pool));
+  if (did_set)
+    *overwrote_working = TRUE;
+
   /* Install the new text base if one is waiting. */
   if (kind == svn_node_file)  /* tmp_text_base exists */
     SVN_ERR (svn_wc__sync_text_base (filepath, pool));
@@ -669,7 +675,7 @@
   apr_pool_t *pool = loggy->pool; 
   int is_this_dir = (strcmp (name, SVN_WC_ENTRY_THIS_DIR) == 0);
   const char *rev = svn_xml_get_attr_value (SVN_WC__LOG_ATTR_REVISION, atts);
-  svn_boolean_t wc_root, overwrote_working = FALSE, remove_executable = FALSE;
+  svn_boolean_t wc_root, overwrote_working = FALSE, remove_executable = FALSE, change_filetype = FALSE;
   const char *full_path;
   const char *pdir, *base_name;
   apr_hash_t *entries;
@@ -679,6 +685,7 @@
   apr_time_t prop_time = 0; /* By default, don't override old stamp. */
   svn_node_kind_t kind;
   svn_wc_adm_access_t *adm_access;
+  const svn_string_t *filetype;
 
   /* Determine the actual full path of the affected item. */
   if (! is_this_dir)
@@ -986,9 +993,14 @@
                     && (propchange->value == NULL))
                   {
                     remove_executable = TRUE;
-                    break;
+                    /*break;*/
                   }
-              }                
+                if (! strcmp (propchange->name, SVN_PROP_FILETYPE))
+                  {
+                    filetype = svn_string_dup(propchange->value, pool);
+                    change_filetype = TRUE;
+                  }
+              }
           }
 
         /* Make the tmp prop file the new pristine one. */
@@ -1021,7 +1033,9 @@
                                                FALSE, pool));
           overwrote_working = TRUE; /* entry needs wc-file's timestamp  */
         }
-      
+      if (change_filetype)
+        SVN_ERR (svn_io_set_file_filetype (full_path, filetype, pool));
+
       /* If the working file was overwritten (due to re-translation)
          or touched (due to +x / -x), then use *that* textual
          timestamp instead. */
Index: subversion/libsvn_wc/adm_ops.c
===================================================================
--- subversion/libsvn_wc/adm_ops.c	(revision 12628)
+++ subversion/libsvn_wc/adm_ops.c	(working copy)
@@ -1179,6 +1179,7 @@
               = &APR_ARRAY_IDX (propchanges, i, svn_prop_t);
             
             if ((! strcmp (propchange->name, SVN_PROP_EXECUTABLE))
+                || (! strcmp (propchange->name, SVN_PROP_FILETYPE))
                 || (! strcmp (propchange->name, SVN_PROP_KEYWORDS))
                 || (! strcmp (propchange->name, SVN_PROP_EOL_STYLE))
                 || (! strcmp (propchange->name, SVN_PROP_SPECIAL)))
@@ -1297,6 +1298,8 @@
           /* If necessary, tweak the new working file's executable bit. */
           SVN_ERR (svn_wc__maybe_set_executable (NULL, fullpath, adm_access,
                                                  pool));
+          SVN_ERR (svn_wc__maybe_set_filetype (NULL, fullpath, adm_access,
+                                                 pool));
 
           /* Possibly set the timestamp to last-commit-time, rather
              than the 'now' time that already exists. */
Index: subversion/libsvn_wc/translate.c
===================================================================
--- subversion/libsvn_wc/translate.c	(revision 12628)
+++ subversion/libsvn_wc/translate.c	(working copy)
@@ -263,3 +263,25 @@
 
   return SVN_NO_ERROR;
 }
+
+svn_error_t *
+svn_wc__maybe_set_filetype (svn_boolean_t *did_set,
+                              const char *path,
+                              svn_wc_adm_access_t *adm_access,
+                              apr_pool_t *pool)
+{
+  const svn_string_t *propval;
+  SVN_ERR (svn_wc_prop_get (&propval, SVN_PROP_FILETYPE, path, adm_access,
+                            pool));
+
+  if (propval != NULL)
+    {
+      SVN_ERR (svn_io_set_file_filetype (path, propval, pool));
+      if (did_set)
+        *did_set = TRUE;
+    }
+  else if (did_set)
+    *did_set = FALSE;
+
+  return SVN_NO_ERROR;
+}
Index: subversion/libsvn_subr/io.c
===================================================================
--- subversion/libsvn_subr/io.c	(revision 12628)
+++ subversion/libsvn_subr/io.c	(working copy)
@@ -31,6 +31,8 @@
 #endif
 #endif
 
+#include <unixlib/local.h>
+
 #ifndef APR_STATUS_IS_EPERM
 #ifdef EPERM
 #define APR_STATUS_IS_EPERM(s)   ((s) == EPERM)
@@ -558,6 +560,7 @@
     {
       apr_file_t *s;
       apr_finfo_t finfo;
+      svn_string_t *filetype;
 
       SVN_ERR (svn_io_file_open (&s, src, APR_READ, APR_OS_DEFAULT, pool));
       SVN_ERR (svn_io_file_info_get (&finfo, APR_FINFO_PROT, s, pool));
@@ -577,6 +580,10 @@
           return svn_error_wrap_apr
             (apr_err, "Can't set permissions on '%s'", dst_tmp);
         }
+
+      SVN_ERR (svn_io_get_file_filetype(&filetype, src_apr, pool));
+      SVN_ERR (svn_io_set_file_filetype(dst_tmp_apr, filetype, pool));
+
     }
 #endif /* ! WIN32 */
 
@@ -1089,13 +1096,35 @@
   return SVN_NO_ERROR;
 }
 
+svn_error_t *
+svn_io_set_file_filetype (const char *path,
+                          const svn_string_t *filetype,
+                          apr_pool_t *pool)
+{
+  if (!getenv ("svn$filetypeext"))
+    {
+      int filetype_val = 0xfff;
+      const char *path_apr;
+      char buf[_POSIX_PATH_MAX];
 
+      SVN_ERR (svn_path_cstring_from_utf8 (&path_apr, path, pool));
+
+      if (filetype && filetype->len > 0)
+      	filetype_val = 0xfff & strtol(filetype->data, NULL, 16);
+
+      __object_set_attrs (path_apr, buf, sizeof (buf), filetype_val, __ATTR_NOTSPECIFIED);
+    }
+
+  return SVN_NO_ERROR;
+}
+
+
 svn_error_t *
 svn_io_is_file_executable(svn_boolean_t *executable, 
                           const char *path, 
                           apr_pool_t *pool)
 {
-#if defined(APR_HAS_USER) && !defined(WIN32)
+#if defined(APR_HAS_USER) && !defined(WIN32) && !defined(__riscos__)
   apr_finfo_t file_info;
   apr_status_t apr_err;
   apr_uid_t uid;
@@ -1137,6 +1166,38 @@
   return SVN_NO_ERROR;
 }
 
+
+svn_error_t *
+svn_io_get_file_filetype(svn_string_t **filetype,
+                          const char *path,
+                          apr_pool_t *pool)
+{
+
+  if (getenv("svn$filetypeext"))
+    {
+      *filetype = NULL;
+    }
+  else
+    {
+      const char *path_apr;
+      char buf[_POSIX_PATH_MAX];
+      int filetype_val;
+
+      SVN_ERR (svn_path_cstring_from_utf8 (&path_apr, path, pool));
+
+      __object_get_attrs (path_apr, buf, sizeof (buf), NULL, &filetype_val, NULL, NULL, NULL, NULL);
+
+      if (filetype_val == __RISCOSIFY_FILETYPE_NOTFOUND)
+        filetype_val = 0xfff;
+
+      *filetype = svn_string_createf (pool, "%.3X", filetype_val);
+
+    }
+
+  return SVN_NO_ERROR;
+}
+
+
 
 /*** File locking. ***/
 /* Clear all outstanding locks on ARG, an open apr_file_t *. */
Index: subversion/libsvn_client/export.c
===================================================================
--- subversion/libsvn_client/export.c	(revision 12628)
+++ subversion/libsvn_client/export.c	(working copy)
@@ -194,7 +194,7 @@
           svn_subst_eol_style_t style;
           apr_hash_t *props;
           const char *base;
-          svn_string_t *eol_style, *keywords, *executable, *externals, *special;
+          svn_string_t *eol_style, *keywords, *filetype, *executable, *externals, *special;
           const char *eol = NULL;
           svn_boolean_t local_mod = FALSE;
           apr_time_t tm;
@@ -240,6 +240,8 @@
                                    APR_HASH_KEY_STRING);
           executable = apr_hash_get (props, SVN_PROP_EXECUTABLE,
                                      APR_HASH_KEY_STRING);
+          filetype = apr_hash_get (props, SVN_PROP_FILETYPE,
+                                   APR_HASH_KEY_STRING);
           externals = apr_hash_get (props, SVN_PROP_EXTERNALS,
                                     APR_HASH_KEY_STRING);
           special = apr_hash_get (props, SVN_PROP_SPECIAL,
@@ -292,6 +294,8 @@
           if (executable)
             SVN_ERR (svn_io_set_file_executable (copy_to, TRUE, 
                                                  FALSE, iterpool));
+          if (filetype)
+            SVN_ERR (svn_io_set_file_filetype (copy_to, filetype, iterpool));
 
           if (! special)
             SVN_ERR (svn_io_set_file_affected_time (tm, copy_to, iterpool));
@@ -393,6 +397,7 @@
   const svn_string_t *eol_style_val;
   const svn_string_t *keywords_val;
   const svn_string_t *executable_val;
+  const svn_string_t *filetype_val;
   svn_boolean_t special;
 
   /* Any keyword vals to be substituted */
@@ -589,6 +594,9 @@
   else if (strcmp (name, SVN_PROP_EXECUTABLE) == 0)
     fb->executable_val = svn_string_dup (value, fb->pool);
 
+  else if (strcmp (name, SVN_PROP_FILETYPE) == 0)
+    fb->filetype_val = svn_string_dup (value, fb->pool);
+
   /* Try to fill out the baton's keywords-structure too. */
   else if (strcmp (name, SVN_PROP_ENTRY_COMMITTED_REV) == 0)
     fb->revision = apr_pstrdup (fb->pool, value->data);
@@ -681,10 +689,13 @@
 
       SVN_ERR (svn_io_remove_file (fb->tmppath, pool));
     }
-      
+
   if (fb->executable_val)
     SVN_ERR (svn_io_set_file_executable (fb->path, TRUE, FALSE, pool));
 
+  if (fb->filetype_val)
+    SVN_ERR (svn_io_set_file_filetype (fb->path, fb->filetype_val, pool));
+
   if (fb->date && (! fb->special))
     SVN_ERR (svn_io_set_file_affected_time (fb->date, fb->path, pool));
 
Index: subversion/libsvn_client/add.c
===================================================================
--- subversion/libsvn_client/add.c	(revision 12628)
+++ subversion/libsvn_client/add.c	(working copy)
@@ -192,6 +192,15 @@
                       svn_string_create ("", pool));
     }
 
+    {
+      svn_string_t *filetype;
+      SVN_ERR (svn_io_get_file_filetype (&filetype, path, pool));
+      if (filetype)
+        apr_hash_set (autoprops.properties, SVN_PROP_FILETYPE,
+                      strlen (SVN_PROP_FILETYPE),
+                      filetype);
+    }
+
   *mimetype = autoprops.mimetype;
   return SVN_NO_ERROR;
 }
Index: subversion/clients/cmdline/main.c
===================================================================
--- subversion/clients/cmdline/main.c	(revision 12628)
+++ subversion/clients/cmdline/main.c	(working copy)
@@ -49,6 +49,15 @@
 
 #include "svn_private_config.h"
 
+#ifdef __riscos__
+
+#include <unixlib/local.h>
+
+int __riscosify_control = __RISCOSIFY_STRICT_UNIX_SPECS;
+int __feature_imagefs_is_file = 1;
+
+#endif
+
 
 /*** Option Processing ***/
 
@@ -755,6 +764,11 @@
   if (svn_cmdline_init ("svn", stderr) != EXIT_SUCCESS)
     return EXIT_FAILURE;
 
+#ifdef __riscos__
+  if (getenv("svn$filetypeext"))
+    __riscosify_control |= __RISCOSIFY_FILETYPE_EXT | __RISCOSIFY_FILETYPE_NOT_SET;
+#endif
+
   /* Create our top-level pool.  Use a seperate mutexless allocator,
    * given this application is single threaded.
    */
Index: subversion/libsvn_ra_svn/client.c
===================================================================
--- subversion/libsvn_ra_svn/client.c	(revision 12628)
+++ subversion/libsvn_ra_svn/client.c	(working copy)
@@ -40,6 +40,9 @@
 
 #include "ra_svn.h"
 
+// RISC OS SSH support functions
+extern char *svn_ssh_init(const char **args, void **handle);
+
 typedef struct {
   svn_ra_svn_conn_t *conn;
   int protocol_version;
@@ -499,7 +502,7 @@
 
   apr_file_open_stdin(&in_file, pool);
   apr_file_open_stdout(&out_file, pool);
-  conn = svn_ra_svn_create_conn(NULL, in_file, out_file, pool);
+  conn = svn_ra_svn_create_conn(NULL, in_file, out_file, NULL, pool);
   err = svn_error_wrap_apr(status, NULL, "Error in child process: %s", desc);
   svn_error_clear(svn_ra_svn_write_cmd_failure(conn, pool, err));
   svn_error_clear(svn_ra_svn_flush(conn, pool));
@@ -508,45 +511,18 @@
 static svn_error_t *make_tunnel(const char **args, svn_ra_svn_conn_t **conn,
                                 apr_pool_t *pool)
 {
-  apr_status_t status;
-  apr_proc_t *proc;
-  apr_procattr_t *attr;
+  void *handle;
+  char *err;
 
-  status = apr_procattr_create(&attr, pool);
-  if (status == APR_SUCCESS)
-    status = apr_procattr_io_set(attr, 1, 1, 0);
-  if (status == APR_SUCCESS)
-    status = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);
-  if (status == APR_SUCCESS)
-    status = apr_procattr_child_errfn_set(attr, handle_child_process_error);
-  proc = apr_palloc(pool, sizeof(*proc));
-  if (status == APR_SUCCESS)
-    status = apr_proc_create(proc, *args, args, NULL, attr, pool);
-  if (status != APR_SUCCESS)
-    return svn_error_wrap_apr(status, NULL, "Can't create tunnel");
+  // on RISC OS we use modified io routines to call our ssh ones
+  err = svn_ssh_init(args, &handle);
 
-  /* Arrange for the tunnel agent to get a SIGKILL on pool
-   * cleanup.  This is a little extreme, but the alternatives
-   * weren't working out:
-   *   - Closing the pipes and waiting for the process to die
-   *     was prone to mysterious hangs which are difficult to
-   *     diagnose (e.g. svnserve dumps core due to unrelated bug;
-   *     sshd goes into zombie state; ssh connection is never
-   *     closed; ssh never terminates).
-   *   - Killing the tunnel agent with SIGTERM leads to unsightly
-   *     stderr output from ssh.
-   */
-  apr_pool_note_subprocess(pool, proc, APR_KILL_ALWAYS);
+  if (err)
+    return svn_error_createf(SVN_ERR_RA_NOT_AUTHORIZED, NULL, 
+                             "Unable to start SSH: %s", err);
 
-  /* APR pipe objects inherit by default.  But we don't want the
-   * tunnel agent's pipes held open by future child processes
-   * (such as other ra_svn sessions), so turn that off. */
-  apr_file_inherit_unset(proc->in);
-  apr_file_inherit_unset(proc->out);
-
   /* Guard against dotfile output to stdout on the server. */
-  *conn = svn_ra_svn_create_conn(NULL, proc->out, proc->in, pool);
-  (*conn)->proc = proc;
+  *conn = svn_ra_svn_create_conn(NULL, NULL, NULL, handle, pool);
   SVN_ERR(svn_ra_svn_skip_leading_garbage(*conn, pool));
   return SVN_NO_ERROR;
 }
@@ -577,7 +553,7 @@
   else
     {
       SVN_ERR(make_connection(hostname, port, &sock, pool));
-      conn = svn_ra_svn_create_conn(sock, NULL, NULL, pool);
+      conn = svn_ra_svn_create_conn(sock, NULL, NULL, NULL, pool);
     }
 
   /* Read server's greeting. */
Index: subversion/libsvn_ra_svn/marshal.c
===================================================================
--- subversion/libsvn_ra_svn/marshal.c	(revision 12628)
+++ subversion/libsvn_ra_svn/marshal.c	(working copy)
@@ -39,19 +39,26 @@
 
 #define svn_iswhitespace(c) ((c) == ' ' || (c) == '\n')
 
+// RISC OS SSH support functions
+extern svn_boolean_t ssh_poll(void *handle);
+extern apr_status_t ssh_send(void *handle, const char *data, apr_size_t *count);
+extern apr_status_t ssh_recv(void *handle, char *data, apr_size_t *count);
+
 /* --- CONNECTION INITIALIZATION --- */
 
 svn_ra_svn_conn_t *svn_ra_svn_create_conn(apr_socket_t *sock,
                                           apr_file_t *in_file,
                                           apr_file_t *out_file,
+                                          void *ssh_handle,
                                           apr_pool_t *pool)
 {
   svn_ra_svn_conn_t *conn = apr_palloc(pool, sizeof(*conn));
 
-  assert((sock && !in_file && !out_file) || (!sock && in_file && out_file));
+  //assert((sock && !in_file && !out_file) || (!sock && in_file && out_file));
   conn->sock = sock;
   conn->in_file = in_file;
   conn->out_file = out_file;
+  conn->ssh_handle = ssh_handle;
   conn->read_ptr = conn->read_buf;
   conn->read_end = conn->read_buf;
   conn->write_pos = 0;
@@ -98,8 +105,10 @@
   conn->block_baton = baton;
   if (conn->sock)
     apr_socket_timeout_set(conn->sock, interval);
+  else if (conn->out_file)
+    apr_file_pipe_timeout_set(conn->out_file, interval);
   else
-    apr_file_pipe_timeout_set(conn->out_file, interval);
+    ssh_timeout_set(conn->ssh_handle, interval);
 }
 
 svn_boolean_t svn_ra_svn__input_waiting(svn_ra_svn_conn_t *conn,
@@ -108,6 +117,9 @@
   apr_pollfd_t pfd;
   int n;
 
+  if (conn->ssh_handle)
+      return ssh_poll(conn->ssh_handle);
+
   if (conn->sock)
     {
       pfd.desc_type = APR_POLL_SOCKET;
@@ -153,8 +165,10 @@
       count = end - data;
       if (conn->sock)
         status = apr_socket_send(conn->sock, data, &count);
+      else if (conn->out_file)
+        status = apr_file_write(conn->out_file, data, &count);
       else
-        status = apr_file_write(conn->out_file, data, &count);
+        status = ssh_send(conn->ssh_handle, data, &count);
       if (status)
         return svn_error_wrap_apr(status, "Can't write to connection");
       if (count == 0)
@@ -241,8 +255,10 @@
     apr_socket_timeout_set(conn->sock, -1);
   if (conn->sock)
     status = apr_socket_recv(conn->sock, data, len);
+  else if (conn->in_file)
+    status = apr_file_read(conn->in_file, data, len);
   else
-    status = apr_file_read(conn->in_file, data, len);
+    status = ssh_recv(conn->ssh_handle, data, len);
   if (conn->sock && conn->block_handler)
     apr_socket_timeout_set(conn->sock, 0);
   if (status && !APR_STATUS_IS_EOF(status))
@@ -353,7 +369,7 @@
 }
 
 /* --- WRITING DATA ITEMS --- */
- 
+
 svn_error_t *svn_ra_svn_write_number(svn_ra_svn_conn_t *conn, apr_pool_t *pool,
                                      apr_uint64_t number)
 {
Index: subversion/libsvn_ra_svn/ra_svn.h
===================================================================
--- subversion/libsvn_ra_svn/ra_svn.h	(revision 12628)
+++ subversion/libsvn_ra_svn/ra_svn.h	(working copy)
@@ -43,6 +43,7 @@
   apr_file_t *in_file;
   apr_file_t *out_file;
   apr_proc_t *proc;       /* Used by client.c when sock is NULL */
+  void *ssh_handle;	  /* used in RISC OS for SSH connections */
   char read_buf[4096];
   char *read_ptr;
   char *read_end;
Index: subversion/svnserve/main.c
===================================================================
--- subversion/svnserve/main.c	(revision 12628)
+++ subversion/svnserve/main.c	(working copy)
@@ -361,7 +361,7 @@
                                 redirect_stdout);
       apr_file_open_stdin(&in_file, pool);
       apr_file_open_stdout(&out_file, pool);
-      conn = svn_ra_svn_create_conn(NULL, in_file, out_file, pool);
+      conn = svn_ra_svn_create_conn(NULL, in_file, out_file, NULL, pool);
       svn_error_clear(serve(conn, &params, pool));
       exit(0);
     }
@@ -441,7 +441,7 @@
           exit(1);
         }
 
-      conn = svn_ra_svn_create_conn(usock, NULL, NULL, connection_pool);
+      conn = svn_ra_svn_create_conn(usock, NULL, NULL, NULL, connection_pool);
 
       if (run_mode == run_mode_listen_once)
         {
